<div>
 {{SpiderMonkeySidebar("JSAPI")}}</div>
<div>
 {{jsapi_minversion_header("1.8.5")}}</div>
<div class="summary">
 <p>Flattens a string. This makes getting the characters of the string infallible.</p>
</div>
<h2 id="Syntax" name="Syntax">Syntax</h2>
<pre class="brush: cpp">JSFlatString *
JS_FlattenString(JSContext *cx, JSString *str);
</pre>
<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Name</th>
   <th>Type</th>
   <th>Description</th>
  </tr>
  <tr>
   <td><code>cx</code></td>
   <td>{{jsapixref("JSRuntime", "JSContext *")}}</td>
   <td>The context. {{ Jsapi-requires-request() }}</td>
  </tr>
  <tr>
   <td><code>str</code></td>
   <td>{{jsapixref("JSString", "JSString *")}}</td>
   <td>The string to flatten.</td>
  </tr>
 </tbody>
</table>
<h2 id="Description" name="Description">Description</h2>
<p><code>JS_FlattenString</code> flattens a string <code>str</code> and returns a pointer to {{jsapixref("JSString", "JSFlatString")}}.</p>
<p>To catch errors, an opaque <code>JSFlatString</code> type is returned.</p>
<div class="note">
 <strong>Note:</strong> The input and output of <code>JS_FlattenString()</code> are the same actual GC-thing so only one needs to be rooted.</div>
<p>If a <code>JSString</code> is known to be flat, you can use {{jsapixref("JS_ASSERT_STRING_IS_FLAT")}} to make a debug-checked cast. Example:</p>
<pre class="brush: cpp">// In a fallible situation

JSFlatString *fstr = JS_FlattenString(cx, str);
if (!fstr)
  return false;
JS_ASSERT(fstr == JS_ASSERT_STRING_IS_FLAT(str));

// in an infallible situation, for the same 'str'

const jschar *chars = JS_GetFlatStringChars(fstr)
JS_ASSERT(chars);
</pre>
<h2 id="See_Also" name="See_Also">See Also</h2>
<ul>
 <li>{{ LXRSearch("ident", "i", "JS_FlattenString") }}</li>
 <li>{{jsapixref("JS_ASSERT_STRING_IS_FLAT")}}</li>
 <li>{{jsapixref("JS_FORGET_STRING_FLATNESS")}}</li>
 <li>{{bug(609440)}}</li>
</ul>