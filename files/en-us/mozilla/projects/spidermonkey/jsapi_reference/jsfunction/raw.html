<div>{{SpiderMonkeySidebar("JSAPI")}}</div>
<p><strong><code>JSFunction</code></strong> is a type in the JSAPI. The APIs {{jsapixref("JS_NewFunction")}}, {{jsapixref("JS_DefineFunction")}}, {{jsapixref("JS_CompileFunction")}}, and their Unicode equivalents return values of type <code>JSFunction *</code>.</p>
<p><strong>For native functions and JSAPI-compiled functions</strong> - that is, functions returned by the APIs listed above-there is a simple one-to-one relationship between the <code>JSFunction</code> and the corresponding JavaScript <code>Function</code> object. To get a <code>JSFunction *</code> given the <code>JSObject *</code> of a <code>Function</code> object, use {{jsapixref("JS_ValueToFunction")}}. To get the <code>JSObject *</code> given the <code>JSFunction *</code>, use {{jsapixref("JS_GetFunctionObject")}}.</p>
<p><strong>For other function objects</strong> - that is, functions created by running JavaScript code containing function declarations or function-expressions-the relationship between the <code>JSFunction *</code> and the <code>JSObject *</code> is not well-defined. Different closures (Function objects) generated from the same source code may share the same <code>JSFunction</code>. As a result, some APIs (such as {{jsapixref("JS_CallFunction")}}) that operate on <code>JSFunction</code>s do not work properly with closures. The documentation for each affected API contains a warning about the problem.</p>
<p>If the application can't be sure that a given function JSObject is either native or JSAPI-compiled, it must not use the affected APIs. Instead of using <code>JS_CallFunction</code>, for example, it must call {{jsapixref("JS_CallFunctionValue")}}.</p>
<p>Function objects created by calling {{jsapixref("JS_NewFunction")}} have two reserved slots for the application's use. See {{jsapixref("JS_NewFunction")}} for details.</p>
<h2 id="See_Also" name="See_Also">See Also</h2>
<ul>
 <li>{{ LXRSearch("ident", "i", "JSFunction") }}</li>
</ul>