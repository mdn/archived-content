<div>
 {{SpiderMonkeySidebar("JSAPI")}}</div>
<p>{{ obsolete_header("jsapi17") }}</p>
<div class="summary">
  <p><code>JSGetObjectOps</code> is the type for {{jsapixref("JSClass", "JSClass.getObjectOps")}}</p>
</div>
<h2 id="Callback_Syntax" name="Callback_Syntax">Callback Syntax</h2>
<pre class="brush: cpp">typedef JSObjectOps *
(* JSGetObjectOps)(JSContext *cx, JSClass *clasp);
</pre>
<table class="fullwidth-table">
 <tbody>
  <tr>
   <th>Name</th>
   <th>Type</th>
   <th>Description</th>
  </tr>
  <tr>
   <td><code>cx</code></td>
   <td>{{jsapixref("JSContext", "JSContext *")}}</td>
   <td>The JS context in which the new object is being created.</td>
  </tr>
  <tr>
   <td><code>cls</code></td>
   <td>{{jsapixref("JSClass", "JSClass *")}}</td>
   <td>The class of the new object.</td>
  </tr>
 </tbody>
</table>
<h2 id="Description" name="Description">Description</h2>
<p><strong><code>JSObjectOps</code></strong> is used by {{jsapixref("JS_NewObject")}}'s internals to discover the set of high-level object operations to use for new objects of the given class. All native objects have a {{jsapixref("JSClass")}}, which is stored as a private (int-tagged) pointer in object slots. In contrast, all native and host objects have a {{jsapixref("JSObjectMap")}} at <code>obj-&gt;map</code>, which may be shared among a number of objects, and which contains the {{jsapixref("JSObjectOps", "JSObjectOps *ops")}} pointer used to dispatch object operations from API calls.</p>
<p>Thus <code>JSClass</code> (which pre-dates <code>JSObjectOps</code> in the API) provides a low-level interface to class-specific code and data, while <code>JSObjectOps</code> allows for a higher level of operation, which does not use the object's class except to find the class's <code>JSObjectOps</code> struct, by calling <code>clasp-&gt;getObjectOps</code>, and to finalize the object.</p>
<p>If this seems backwards, that's because it is! API compatibility requires a <code>JSClass *clasp</code> parameter to <code>JS_NewObject</code>, etc. Most host objects do not need to implement the larger <code>JSObjectOps</code>, and can share the common <code>JSScope</code> code and data used by the native (<code>js_ObjectOps</code>, see jsobj.c) ops.</p>
<p>Further extension to preserve API compatibility: if this function returns a pointer to {{jsapixref("JSXMLObjectOps", "JSXMLObjectOps.base")}}, not to <code>JSObjectOps</code>, then the engine calls extended hooks needed for E4X.</p>

<h3 id="JSClass_hooks"><code>JSClass</code> hooks</h3>

<p>JSClass offerd following hook:</p>

<ul>
<li>
  <p>The <strong>{{jsapixref("JSClass", "JSClass.getObjectOps")}}</strong> hook is called each time an object is created. It returns a pointer to a {{jsapixref("JSObjectOps")}} which is then used as a virtual table for operations on the new object.</p>
</li>
</ul>

<h2 id="See_Also" name="See_Also">See Also</h2>
<ul>
 <li>{{ LXRSearch("ident", "i", "JSHasInstanceOp") }}</li>
<li>{{jsapixref("JSClass")}}</li>
 <li>{{jsapixref("JS_HasInstance")}}</li>
 <li>{{bug(571789)}}</li>
</ul>