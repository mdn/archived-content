---
title: WebIDL bindings
slug: Mozilla/WebIDL_bindings
tags:
  - Guide
  - WebIDL
---
<div class="note">
<p>Notes: Need to document the setup for indexed and named setters/creators/deleters.</p>
</div>

<p>The <a class="external" href="https://heycam.github.io/webidl/">WebIDL</a> bindings are generated at build time based on two things: the actual WebIDL file and a configuration file that lists some metadata about how the WebIDL should be reflected into Gecko-internal code.</p>

<p>All WebIDL files should be placed in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/webidl/"><code>dom/webidl</code></a> and added to the list in the <a href="https://dxr.mozilla.org/mozilla-central/source/dom/webidl/moz.build">moz.build</a> file in that directory.</p>

<p>Note that if you&apos;re adding new interfaces, then the test at <code><span class="s0"><a href="https://dxr.mozilla.org/mozilla-central/source/dom/tests/mochitest/general/test_interfaces.html">dom/tests/mochitest/general/test_interfaces.html</a> </span></code>will most likely fail. This is a signal that you need to get a review from a <a href="https://wiki.mozilla.org/Modules/All#Document_Object_Model">DOM peer</a>. Resist the urge to just add your interfaces to the <a href="https://dxr.mozilla.org/mozilla-central/source/dom/webidl/moz.build">moz.build</a> list without the review; it will just annoy the DOM peers and they&apos;ll make you get the review anyway.</p>

<p>The configuration file, <code><a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/Bindings.conf">dom/bindings/Bindings.conf</a>,</code> is basically a Python dict that maps interface names to information about the interface, called a <em>descriptor</em>. There are all sorts of possible options here that handle various edge cases, but most descriptors can be very simple.</p>

<p>All the generated code is placed in the <code>mozilla::dom</code> namespace. For each interface, a namespace whose name is the name of the interface with <code>Binding</code> appended is created, and all the things pertaining to that interface&apos;s binding go in that namespace.</p>

<p>There are various helper objects and utility methods in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/"><code>dom/bindings</code></a> that are also all in the <code>mozilla::dom</code> namespace and whose headers are all exported into <code>mozilla/dom</code> (placed in <code><code>$OBJDIR/dist/include</code></code> by the build process).</p>

<h2 id="Adding_WebIDL_bindings_to_a_class">Adding WebIDL bindings to a class</h2>

<p>To add a WebIDL binding for interface <code>MyInterface</code> to a class <code>mozilla::dom::MyInterface</code> that&apos;s supposed to implement that interface, you need to do the following:</p>

<ol>
	<li>
	<p>If your interface doesn&apos;t inherit from any other interfaces, inherit from <code>nsWrapperCache</code> and hook up the class to the cycle collector so it will trace the wrapper cache properly. Note that you may not need to do this if your objects can only be created, never gotten from other objects. If you also inherit from <code>nsISupports</code>, make sure the <code>nsISupports</code> comes before the <code>nsWrapperCache</code> in your list of parent classes. If your interface <em>does</em> inherit from another interface, just inherit from the C++ type that the other interface corresponds to.</p>

	<p>If you do need to hook up cycle collection, it will look like this in the common case of also inheriting from nsISupports:</p>

	<pre class="brush: cpp notranslate">// Add strong pointers your class holds here. If you do, change to using
// NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE.
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(MyClass)
NS_IMPL_CYCLE_COLLECTING_ADDREF(MyClass)
NS_IMPL_CYCLE_COLLECTING_RELEASE(MyClass)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(MyClass)
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
NS_INTERFACE_MAP_END</pre>
	</li>
	<li>If your class doesn&apos;t inherit from a class that implements <code>GetParentObject</code>, then add a function of that name that, for a given instance of your class, returns the same object every time (unless you write explicit code that handles your parent object changing by reparenting JS wrappers, as nodes do). The idea is that walking the <code>GetParentObject</code> chain will eventually get you to a Window, so that every WebIDL object is associated with a particular Window.<br>
	<br>
	For example, <code>nsINode::GetParentObject</code> returns the node&apos;s owner document. The return type of <code>GetParentObject</code> doesn&apos;t matter other than it must either singly-inherit from <code>nsISupports</code> or have a corresponding <a href="https://dxr.mozilla.org/mozilla-central/search?q=function%3AToSupports&amp;case=true"><code>ToSupports</code></a> method that can produce an <code>nsISupports</code> from it. (This allows the return value to be implicitly converted to a <a href="https://dxr.mozilla.org/mozilla-central/search?q=type%3AParentObject&amp;case=true&amp;redirect=true">ParentObject</a> instance by the compiler via one of that class&apos;s non-explicit constructors.)<br>
	<br>
	If many instances of <code>MyInterface</code> are expected to be created quicky, the return value of <code>GetParentObject</code> should itself inherit from <code>nsWrapperCache</code> for optimal performance. Returning null from <code>GetParentObject</code> is allowed in situations in which it&apos;s OK to associate the resulting object with a random global object for security purposes; this is not usually ok for things that are exposed to web content. Again, if you do not need wrapper caching you don&apos;t need to do this.  The actual type returned from <code>GetParentObject</code> must be defined in a header included from your implementation header, so that this type&apos;s definition is visible to the binding code.</li>
	<li>Add the WebIDL for <code>MyInterface</code> in <code>dom/webidl</code> and to the list in <code>dom/webidl/moz.build</code>.</li>
	<li>Add an entry to <code>dom/bindings/Bindings.conf</code> that sets some basic information about the implementation of the interface. If the C++ type is not <code>mozilla::dom::MyInterface</code>, you need to set the <code>&apos;nativeType&apos;</code> to the right type. If the type is not in the header file one gets by replacing &apos;::&apos; with &apos;/&apos; and appending &apos;<code>.h</code>&apos;, then add a corresponding <code>&apos;headerFile&apos;</code> annotation (or <a href="#HeaderFile" title="#HeaderFile"><code>HeaderFile</code></a> annotation to the .webidl file). If you don&apos;t have to set any annotations, then you don&apos;t need to add an entry either and the code generator will simply assume the defaults here.  Note that using a <code>&apos;headerFile&apos;</code> annotation is generally not recommended.  If you do use it, you will need to make sure your header includes all the headers needed for your <a href="#Func"><code>Func</code></a> annotations.</li>
	<li>Add external interface entries to <code>Bindings.conf</code> for whatever non-WebIDL interfaces your new interface has as arguments or return values.</li>
	<li>Implement a <code>WrapObject</code> override on <code>mozilla::dom::MyInterface</code> that just calls through to <code>mozilla::dom::MyInterface_Binding::Wrap</code>. Note that if your C++ type is implementing multiple distinct Web IDL interfaces, you need to choose which <code>mozilla::dom::MyInterface_Binding::Wrap</code> to call here. See <code>AudioContext::WrapObject</code>,  for example.</li>
	<li>Expose whatever methods the interface needs on <code>mozilla::dom::MyInterface</code>. These can be inline, virtual, have any calling convention, and so forth, as long as they have the right argument types and return types. You can see an example of what the function declarations should look like by running <code>mach webidl-example MyInterface</code>. This will produce two files in <code>dom/bindings</code> in your objdir: <code>MyInterface-example.h</code> and <code>MyInterface-example.cpp</code>, which show a basic implementation of the interface using a class that inherits from <code>nsISupports</code> and has a wrapper cache.</li>
</ol>

<p>See this <a class="link-https" href="https://hg.mozilla.org/mozilla-central/rev/dd08c10193c6" title="https://hg.mozilla.org/mozilla-central/rev/dd08c10193c6">sample patch that migrates window.performance.* to WebIDL bindings</a>.</p>

<div class="note"><strong>Note:</strong> If your object can only be reflected into JS by creating it, not by retrieving it from somewhere, you can skip steps 1 and 2 above and instead add <code>&apos;wrapperCache&apos;: False</code> to your descriptor. You will need to flag the functions that return your object as <a class="external" href="https://heycam.github.io/webidl/#NewObject"><code>[NewObject]</code></a> in the WebIDL. If your object is not refcounted then the return value of functions that return it should return an nsAutoPtr.</div>

<h2 id="C_reflections_of_WebIDL_constructs">C++ reflections of WebIDL constructs</h2>

<h3 id="C_reflections_of_WebIDL_operations_methods">C++ reflections of WebIDL operations (methods)</h3>

<p><br>
A WebIDL operation is turned into a method call on the underlying C++ object. The return type and argument types are determined <a href="#typemapping" title="#typemapping">as described below</a>. In addition to those, all <a href="#Throws">methods that are allowed to throw</a> will get an <code>ErrorResult&amp;</code> argument appended to their argument list. Non-static methods that use certain WebIDL types like <code>any</code> or <code>object</code> will get a <code>JSContext*</code> argument prepended to the argument list. Static methods will be passed a <a href="#GlobalObject" title="#GlobalObject"><code>const GlobalObject&amp;</code></a> for the relevant global and can get a <code>JSContext*</code> by calling <code>Context()</code> on it.</p>

<p>The name of the C++ method is simply the name of the WebIDL operation with the first letter converted to uppercase.</p>

<p>WebIDL overloads are turned into C++ overloads: they simply call C++ methods with the same name and different signatures.</p>

<p>For example, this webidl:</p>

<pre class="notranslate">interface MyInterface
{
  void doSomething(long number);
  double doSomething(MyInterface? otherInstance);

  [Throws]
  MyInterface doSomethingElse(optional long maybeNumber);
  [Throws]
  void doSomethingElse(MyInterface otherInstance);

  void doTheOther(any something);

  void doYetAnotherThing(optional boolean actuallyDoIt = false);

  static void staticOperation(any arg);
};
</pre>

<p>will require these method declarations:</p>

<pre class="brush: cpp notranslate">class MyClass
{
  void DoSomething(int32_t aNumber);
  double DoSomething(MyClass* aOtherInstance);

  already_AddRefed&lt;MyInterface&gt; DoSomethingElse(Optional&lt;int32_t&gt; aMaybeNumber,
                                                ErrorResult&amp; rv);
  void DoSomethingElse(MyClass&amp; aOtherInstance, ErrorResult&amp; rv);

  void DoTheOther(JSContext* cx, JS::Value aSomething);

  void DoYetAnotherThing(bool aActuallyDoIt);

  static void StaticOperation(const GlobalObject&amp; aGlobal, JS::Value aSomething);
}
</pre>

<h3 id="C_reflections_of_WebIDL_attributes">C++ reflections of WebIDL attributes</h3>

<p>A WebIDL attribute is turned into a pair of method calls for the getter and setter on the underlying C++ object. A readonly attribute only has a getter and no setter.</p>

<p>The getter&apos;s name is the name of the attribute with the first letter converted to uppercase. This has <code>Get</code> prepended to it if any of these conditions hold:</p>

<ol>
	<li>The type of the attribute is nullable.</li>
	<li>The getter can throw.</li>
	<li>The return value of the attribute is returned via an out parameter in the C++.</li>
</ol>

<p>The method signature for the getter looks just like an operation with no arguments and the attribute&apos;s type as the return type.</p>

<p>The setter&apos;s name is <code>Set</code> followed by the name of the attribute with the first letter converted to uppercase. The method signature looks just like an operation with a void return value and a single argument whose type is the attribute&apos;s type.</p>

<h3 id="C_reflections_of_WebIDL_constructors">C++ reflections of WebIDL constructors</h3>

<p>A WebIDL constructor is turned into a static class method named <code>Constructor</code>. The arguments of this method will be the arguments of the WebIDL constructor, with a <a href="#GlobalObject" title="#GlobalObject"><code>const GlobalObject&amp;</code></a> for the relevant global prepended. For the non-worker case, the global is typically the inner window for the DOM Window the constructor function is attached to. If a <code>JSContext*</code> is also needed due to some of the argument types, it will come after the global. The return value of the constructor for <code>MyInterface</code> is exactly the same as that of a method returning an instance of <code>MyInterface</code>. Constructors are always allowed to throw.</p>

<p>For example, this IDL:</p>

<pre class="notranslate">[Constructor,
 Constructor(unsigned long someNumber)]
interface MyInterface
{
};
</pre>

<p>will require the following declarations in <code>MyClass</code>:</p>

<pre class="brush: cpp notranslate">class MyClass {
  // Various nsISupports stuff or whatnot
  static
  already_AddRefed&lt;MyClass&gt; Constructor(const GlobalObject&amp; aGlobal,
                                        ErrorResult&amp; rv);
  static
  already_AddRefed&lt;MyClass&gt; Constructor(const GlobalObject&amp; aGlobal,
                                        uint32_t aSomeNumber,
                                        ErrorResult&amp; rv);
};
</pre>

<h3 id="typemapping" name="typemapping">C++ reflections of WebIDL types</h3>

<p>The exact C++ representation for WebIDL types can depend on the precise way that they&apos;re being used (e.g., return values, arguments, and sequence or dictionary members might all have different representations).</p>

<p>Unless stated otherwise, a type only has one representation. Also, unless stated otherwise, nullable types are represented by wrapping <a href="#Nullable" title="#Nullable"><code>Nullable&lt;&gt;</code></a> around the base type.</p>

<p>In all cases, optional arguments which do not have a default value are represented by wrapping <a href="#Optional" title="#Optional"><code>const Optional&lt;&gt;&amp;</code></a> around the representation of the argument type. If the argument type is a C++ reference, it will also become a <a href="#NonNull" title="#NonNull">NonNull&lt;&gt;</a> around the actual type of the object in the process. Optional arguments which do have a default value are just represented by the argument type itself, set to the default value if the argument was not in fact passed in.</p>

<p>Variadic WebIDL arguments are treated as a <a href="#Sequence" title="#Sequence"><code>const Sequence&lt;&gt;&amp;</code></a> around the actual argument type.</p>

<p>Here&apos;s a table, see the specific sections below for more details and explanations.</p>

<table class="standard-table">
	<tbody>
		<tr>
			<td><strong>WebIDL Type</strong></td>
			<td><strong>Argument Type</strong></td>
			<td><strong>Return Type</strong></td>
			<td><strong>Dictionary/Member Type</strong></td>
		</tr>
		<tr>
			<td><strong>any</strong></td>
			<td><code>JS::Handle&lt;JS::Value&gt;</code></td>
			<td><code>JS::MutableHandle&lt;JS::Value&gt;</code></td>
			<td><code>JS::Value</code></td>
		</tr>
		<tr>
			<td><strong>boolean</strong></td>
			<td><code>bool</code></td>
			<td><code>bool</code></td>
			<td><code>bool</code></td>
		</tr>
		<tr>
			<td><strong>byte</strong></td>
			<td><code>int8_t</code></td>
			<td><code>int8_t</code></td>
			<td><code>int8_t</code></td>
		</tr>
		<tr>
			<td><strong>ByteString</strong></td>
			<td><code>const nsACString&amp;</code></td>
			<td><code>nsCString&amp;</code> (outparam)<br>
			<code>nsACString&amp;</code> (outparam)</td>
			<td><code>nsCString</code></td>
		</tr>
		<tr>
			<td><strong>Date</strong></td>
			<td></td>
			<td></td>
			<td><code>mozilla::dom::Date</code></td>
		</tr>
		<tr>
			<td><strong>DOMString</strong></td>
			<td><code>const nsAString&amp;</code></td>
			<td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#DOMString-helper" title="#DOMString-helper"><code>mozilla::dom::DOMString&amp;</code></a> (outparam)<br>
			<code>nsAString&amp;</code> (outparam)<br>
			<code>nsString&amp;</code> (outparam)</td>
			<td><code>nsString</code></td>
		</tr>
		<tr>
			<td><strong>UTF8String</strong></td>
			<td><code>const nsACString&amp;</code></td>
			<td><code>nsACString&amp;</code> (outparam)</td>
			<td><code>nsCString</code></td>
		</tr>
		<tr>
			<td><strong>double</strong></td>
			<td><code>double</code></td>
			<td><code>double</code></td>
			<td><code>double</code></td>
		</tr>
		<tr>
			<td><strong>float</strong></td>
			<td><code>float</code></td>
			<td><code>float</code></td>
			<td><code>float</code></td>
		</tr>
		<tr>
			<td><strong>interface: non-nullable</strong></td>
			<td><code>Foo&amp;</code></td>
			<td><code>already_addRefed&lt;Foo&gt;<br>
			Foo*</code></td>
			<td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#OwningNonNull" title="#OwningNonNull"><code>OwningNonNull&lt;Foo&gt;</code></a></td>
		</tr>
		<tr>
			<td><strong>interface: nullable</strong></td>
			<td><code>Foo*</code></td>
			<td>
			<p><code>already_addRefed&lt;Foo&gt;<br>
			Foo*</code></p>
			</td>
			<td><code>RefPtr&lt;Foo&gt;</code></td>
		</tr>
		<tr>
			<td><strong>long</strong></td>
			<td><code>int32_t</code></td>
			<td><code>int32_t</code></td>
			<td><code>int32_t</code></td>
		</tr>
		<tr>
			<td><strong>long long</strong></td>
			<td><code>int64_t</code></td>
			<td><code>int64_t</code></td>
			<td><code>int64_t</code></td>
		</tr>
		<tr>
			<td><strong>object</strong></td>
			<td><code>JS::Handle&lt;JSObject*&gt;</code></td>
			<td><code>JS::MutableHandle&lt;JSObject*&gt;</code></td>
			<td><code>JSObject*</code></td>
		</tr>
		<tr>
			<td><strong>octet</strong></td>
			<td><code>uint8_t</code></td>
			<td><code>uint8_t</code></td>
			<td><code>uint8_t</code></td>
		</tr>
		<tr>
			<td><strong>sequence</strong></td>
			<td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#Sequence" title="#Sequence"><code>const Sequence&lt;T&gt;&amp;</code></a></td>
			<td><code>nsTArray&lt;T&gt;&amp;</code> (outparam)</td>
			<td></td>
		</tr>
		<tr>
			<td><strong>short</strong></td>
			<td><code>int16_t</code></td>
			<td><code>int16_t</code></td>
			<td><code>int16_t</code></td>
		</tr>
		<tr>
			<td><strong>unrestricted double</strong></td>
			<td><code>double</code></td>
			<td><code>double</code></td>
			<td><code>double</code></td>
		</tr>
		<tr>
			<td><strong>unrestricted float</strong></td>
			<td><code>float</code></td>
			<td><code>float</code></td>
			<td><code>float</code></td>
		</tr>
		<tr>
			<td><strong>unsigned long</strong></td>
			<td><code>uint32_t</code></td>
			<td><code>uint32_t</code></td>
			<td><code>uint32_t</code></td>
		</tr>
		<tr>
			<td><strong>unsigned long long</strong></td>
			<td><code>uint64_t</code></td>
			<td><code>uint64_t</code></td>
			<td><code>uint64_t</code></td>
		</tr>
		<tr>
			<td><strong>unsigned short</strong></td>
			<td><code>uint16_t</code></td>
			<td><code>uint16_t</code></td>
			<td><code>uint16_t</code></td>
		</tr>
		<tr>
			<td><strong>USVString</strong></td>
			<td><code>const nsAString&amp;</code></td>
			<td><a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#DOMString-helper" title="#DOMString-helper"><code>mozilla::dom::DOMString&amp;</code></a> (outparam)<br>
			<code>nsAString&amp;</code> (outparam)<br>
			<code>nsString&amp;</code> (outparam)</td>
			<td><code>nsString</code></td>
		</tr>
	</tbody>
</table>

<h4 id="any"><code>any</code></h4>

<p><code>any</code> is represented in three different ways, depending on use:</p>

<ul>
	<li><code>any</code> arguments become <code>JS::Handle&lt;JS::Value&gt;</code>.  They will be in the compartment of the passed-in JSContext.</li>
	<li><code>any</code> return values become a <code>JS::MutableHandle&lt;JS::Value&gt;</code> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.  The return value is allowed to be in any compartment; bindings will wrap it into the context compartment as needed.</li>
	<li><code>any</code> dictionary members and sequence elements become <code>JS::Value</code>. The dictionary members and sequence elements are guaranteed to be marked by whomever puts the sequence or dictionary on the stack, using <code>SequenceRooter</code> and <code>DictionaryRooter</code>.</li>
</ul>

<p>Methods using <code>any</code> always get a <code>JSContext*</code> argument.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  attribute any myAttr;
  any myMethod(any arg1, sequence&lt;any&gt; arg2, optional any arg3);
};
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">void MyAttr(JSContext* cx, JS::MutableHandle&lt;JS::Value&gt; retval);
void SetMyAttr(JSContext* cx, JS::Handle&lt;JS::Value&gt; value);
void MyMethod(JSContext* cx, JS::Handle&lt;JS::Value&gt; arg1,
              const Sequence&lt;JS::Value&gt;&amp; arg2,
              const Optional&lt;JS::Handle&lt;JS::Value&gt; &gt;&amp; arg3,
              JS::MutableHandle&lt;JS::Value&gt; retval);
</pre>

<h4 id="boolean"><code>boolean</code></h4>

<p>The <code>boolean</code> WebIDL type is represented as a C++ <code>bool</code>.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  attribute boolean myAttr;
  boolean myMethod(optional boolean arg);
};
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">bool MyAttr();
void SetMyAttr(bool value);
JS::Value MyMethod(const Optional&lt;bool&gt;&amp; arg);
</pre>

<h4 id="Integer_types">Integer types</h4>

<p>Integer WebIDL types are mapped to the corresponding C99 stdint types.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  attribute short myAttr;
  long long myMethod(unsigned long? arg);
};
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">int16_t MyAttr();
void SetMyAttr(int16_t value);
int64_t MyMethod(const Nullable&lt;uint32_t&gt;&amp; arg);
</pre>

<h4 id="Floating_point_types">Floating point types</h4>

<p>Floating point WebIDL types are mapped to the C++ type of the same name.  So <code>float</code> and <code>unrestricted float</code> become a C++ <code>float</code>, while <code>double</code> and <code>unrestricted double</code> become a C++ <code>double</code>.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  float myAttr;
  double myMethod(unrestricted double? arg);
};
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">float MyAttr();
void SetMyAttr(float value);
double MyMethod(const Nullable&lt;double&gt;&amp; arg);
</pre>

<h4 id="DOMString"><code>DOMString</code></h4>

<p>Strings are reflected in three different ways, depending on use:</p>

<ul>
	<li>String arguments become <code>const nsAString&amp;</code>.</li>
	<li>String return values become a <a href="#DOMString-helper"><code>mozilla::dom::DOMString&amp;</code></a> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method. Note that this allows callees to declare their methods as taking an <code>nsAString&amp;</code> or <code>nsString&amp;</code> if desired.</li>
	<li>Strings in sequences, dictionaries, owning unions, and variadic arguments become <code>nsString</code>.</li>
</ul>

<p>Nullable strings are represented by the same types as non-nullable ones, but the string will return true for <code>DOMStringIsNull()</code>. Returning null as a string value can be done using <code>SetDOMStringToNull</code> on the out param if it&apos;s an <code>nsAString</code> or calling <code>SetNull()</code> on a <code>DOMString</code>.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  DOMString myAttr;
  [Throws]
  DOMString myMethod(sequence&lt;DOMString&gt; arg1, DOMString? arg2, optional DOMString arg3);
};
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">void GetMyAttr(nsString&amp; retval);
void SetMyAttr(const nsAString&amp; value);
void MyMethod(const Sequence&lt;nsString&gt;&amp; arg1, const nsAString&amp; arg2,
              const Optional&lt;nsAString&gt;&amp; arg3, nsString&amp; retval, ErrorResult&amp; rv);
</pre>

<h4 id="USVString"><code>USVString</code></h4>

<p><code>USVString</code> is reflected just like <code>DOMString</code>.</p>

<h4 id="UTF8String"><code>UTF8String</code></h4>

<p><code>UTF8String</code> is a string with guaranteed-valid UTF-8 contents. It is not an standard in the WebIDL spec, but its observables are the same as those of <code>USVString</code>.</p>

<p>It is a good fit for when the specification allows a <code>USVString</code>, but you want to process the string as UTF-8 rather than UTF-16.</p>

<p>It is reflected in three different ways, depending on use:</p>

<ul>
	<li>Arguments become <code>const nsACString&amp;</code>.</li>
	<li>Return values become an <code>nsACString&amp;</code> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.</li>
	<li>In sequences, dictionaries owning unions, and variadic arguments it becomes <code>nsCString</code>.</li>
</ul>

<p>Nullable <code>UTF8String</code>s are represented by the same types as non-nullable ones, but the string will return true for <code>IsVoid()</code>. Returning null as a string value can be done using <code>SetIsVoid()</code> on the out param.</p>

<h4 id="ByteString"><code>ByteString</code></h4>

<p><code>ByteString</code> is reflected in three different ways, depending on use:</p>

<ul>
	<li><code>ByteString</code> arguments become <code>const nsACString&amp;</code>.</li>
	<li><code>ByteString</code> return values become an <code>nsCString&amp;</code> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.</li>
	<li><code>ByteString</code> in sequences, dictionaries, owning unions, and variadic arguments becomes <code>nsCString</code>.</li>
</ul>

<p>Nullable <code>ByteString</code> are represented by the same types as non-nullable ones, but the string will return true for <code>IsVoid()</code>. Returning null as a string value can be done using <code>SetIsVoid()</code> on the out param.</p>

<h4 id="object"><code>object</code></h4>

<p><code>object</code> is represented in three different ways, depending on use:</p>

<ul>
	<li><code>object</code> arguments become <code>JS::Handle&lt;JSObject*&gt;</code>.  They will be in the compartment of the passed-in JSContext.</li>
	<li><code>object</code> return values become a <code>JS::MutableHandle&lt;JSObject*&gt;</code> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.  The return value is allowed to be in any compartment; bindings will wrap it into the context compartment as needed.</li>
	<li><code>object</code> dictionary members and sequence elements become <code>JSObject*</code>. The dictionary members and sequence elements are guaranteed to be marked by whoever puts the sequence or dictionary on the stack, using <code>SequenceRooter</code> and <code>DictionaryRooter</code>.</li>
</ul>

<p>Methods using <code>object</code> always get a <code>JSContext*</code> argument.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  object myAttr;
  object myMethod(object arg1, object? arg2, sequence&lt;object&gt; arg3, optional object arg4,
                  optional object? arg5);
};</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">void GetMyAttr(JSContext* cx, JS::MutableHandle&lt;JSObject*&gt; retval);
void SetMyAttr(JSContext* cx, JS::Handle&lt;JSObject*&gt; value);
void MyMethod(JSContext* cx, JS::Handle&lt;JSObject*&gt; arg1, JS::Handle&lt;JSObject*&gt; arg2,
              const Sequence&lt;JSObject*&gt;&amp; arg3,
              const Optional&lt;JS::Handle&lt;JSObject*&gt; &gt;&amp; arg4,
              const Optional&lt;JS::Handle&lt;JSObject*&gt; &gt;&amp; arg5,
              JS::MutableHandle&lt;JSObject*&gt; retval);
</pre>

<h4 id="Interface_types">Interface types</h4>

<p>There are four kinds of interface types in the WebIDL bindings. Callback interfaces are used to represent script objects that browser code can call into. External interfaces are used to represent objects that have not been converted to the WebIDL bindings yet. WebIDL interfaces are used to represent WebIDL binding objects. &quot;SpiderMonkey&quot; interfaces are used to represent objects that are implemented natively by the JavaScript engine (e.g., typed arrays).</p>

<h5 id="Callback_interfaces">Callback interfaces</h5>

<p>Callback interfaces are represented in C++ as objects inheriting from <a href="#CallbackInterface" title="#CallbackInterface"><code>mozilla::dom::CallbackInterface</code></a>, whose name, in the <code>mozilla::dom</code> namespace, matches the name of the callback interface in the WebIDL. The exact representation depends on how the type is being used.</p>

<ul>
	<li>Nullable arguments become <code>Foo*</code>.</li>
	<li>Non-nullable arguments become <code>Foo&amp;</code>.</li>
	<li>Return values become <code>already_AddRefed&lt;Foo&gt;</code> or <code>Foo*</code> as desired. The pointer form is preferred because it results in faster code, but it should only be used if the return value was not addrefed (and so it can only be used if the return value is kept alive by the callee until at least the binding method has returned).</li>
	<li>WebIDL callback interfaces in sequences, dictionaries, owning unions, and variadic arguments are represented by <code>RefPtr&lt;Foo&gt;</code> if nullable and <a href="#OwningNonNull"><code>OwningNonNull&lt;Foo&gt;</code></a> otherwise.</li>
</ul>

<p>If the interface is a single-operation interface, the object exposes two methods that both invoke the same underlying JS callable. The first of these methods allows the caller to pass in a <code>this</code> object, while the second defaults to <code>undefined</code> as the <code>this</code> value. In either case, the <code>this</code> value is only used if the callback interface is implemented by a JS callable. If it&apos;s implemented by an object with a property whose name matches the operation, the object itself is always used as <code>this</code>.</p>

<p>If the interface is not a single-operation interface, it just exposes a single method for every IDL method/getter/setter.</p>

<p>The signatures of the methods correspond to the signatures for throwing IDL methods/getters/setters with an additional trailing &quot;<code>mozilla::dom::CallbackObject::ExceptionHandling</code> <code>aExceptionHandling</code>&quot; argument, defaulting to <code>eReportExceptions</code>. If <code>aReportExceptions</code> is set to <code>eReportExceptions</code>, the methods will report JS exceptions before returning. If <code>aReportExceptions</code> is set to <code>eRethrowExceptions</code>, JS exceptions will be stashed in the <code>ErrorResult</code> and will be reported when the stack unwinds to wherever the <code>ErrorResult</code> was set up.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">callback interface MyCallback {
  attribute long someNumber;
  short someMethod(DOMString someString);
};
callback interface MyOtherCallback {
  // single-operation interface
  short doSomething(Node someNode);
};
interface MyInterface {
  attribute MyCallback foo;
  attribute MyCallback? bar;
};</pre>

<p>will lead to these C++ class declarations in the <code>mozilla::dom</code> namespace:</p>

<pre class="brush: cpp notranslate">class MyCallback : public CallbackInterface
{
  int32_t GetSomeNumber(ErrorResult&amp; rv, ExceptionHandling aExceptionHandling = eReportExceptions);
  void SetSomeNumber(int32_t arg, ErrorResult&amp; rv,
                     ExceptionHandling aExceptionHandling = eReportExceptions);
  int16_t SomeMethod(const nsAString&amp; someString, ErrorResult&amp; rv,
                     ExceptionHandling aExceptionHandling = eReportExceptions);
};

class MyOtherCallback : public CallbackInterface
{
public:
  int16_t
  DoSomething(nsINode&amp; someNode, ErrorResult&amp; rv,
              ExceptionHandling aExceptionHandling = eReportExceptions);

  template&lt;typename T&gt;
  int16_t
  DoSomething(const T&amp; thisObj, nsINode&amp; someNode, ErrorResult&amp; rv,
              ExceptionHandling aExceptionHandling = eReportExceptions);
};</pre>

<p>and these C++ function declarations on the implementation of <code>MyInterface</code>:</p>

<pre class="notranslate">already_AddRefed&lt;MyCallback&gt; GetFoo();
void SetFoo(MyCallback&amp;);
already_AddRefed&lt;MyCallback&gt; GetBar();
void SetBar(MyCallback*);
</pre>

<p>A consumer of MyCallback would be able to use it like this:</p>

<pre class="brush: cpp notranslate">void
SomeClass::DoSomethingWithCallback(MyCallback&amp; aCallback)
{
  ErrorResult rv;
  int32_t number = aCallback.GetSomeNumber(rv);
  if (rv.Failed()) {
    // The error has already been reported to the JS console; you can handle
    // things however you want here.
    return;
  }

  // For some reason we want to catch and rethrow exceptions from SetSomeNumber, say.
  aCallback.SetSomeNumber(2*number, rv, eRethrowExceptions);
  if (rv.Failed()) {
    // The exception is now stored on rv. This code MUST report
    // it usefully; otherwise it will assert.
  }
}
</pre>

<h5 id="External_interfaces">External interfaces</h5>

<p>External interfaces are represented in C++ as objects that XPConnect knows how to unwrap to. This can mean XPCOM interfaces (whether declared in XPIDL or not) or it can mean some type that there&apos;s a castable native unwrapping function for. The C++ type to be used should be the <code>nativeType</code> listed for the external interface in the <a href="#Bindings.conf" title="#Bindings.conf"><code>Bindings.conf</code></a> file. The exact representation depends on how the type is being used.</p>

<ul>
	<li>Arguments become <code>nsIFoo*</code>.</li>
	<li>Return values can be <code>already_AddRefed&lt;nsIFoo&gt;</code> or <code>nsIFoo*</code> as desired. The pointer form is preferred because it results in faster code, but it should only be used if the return value was not addrefed (and so it can only be used if the return value is kept alive by the callee until at least the binding method has returned).</li>
	<li>External interfaces in sequences, dictionaries, owning unions, and variadic arguments are represented by <code>RefPtr&lt;nsIFoo&gt;.</code></li>
</ul>

<h5 id="WebIDL_interfaces">WebIDL interfaces</h5>

<p>WebIDL interfaces are represented in C++ as C++ classes. The class involved must either be refcounted or must be explicitly annotated in <code>Bindings.conf</code> as being directly owned by the JS object. If the class inherits from <code>nsISupports</code>, then the canonical <code>nsISupports</code> must be on the primary inheritance chain of the object. If the interface has a parent interface, the C++ class corresponding to the parent must be on the primary inheritance chain of the object. This guarantees that a <code>void*</code> can be stored in the JSObject which can then be <code>reinterpret_cast</code> to any of the classes that correspond to interfaces the object implements. The C++ type to be used should be the <code>nativeType</code> listed for the interface in the <a href="#Bindings.conf" title="#Bindings.conf"><code>Bindings.conf</code></a> file, or <code>mozilla::dom::InterfaceName</code> if none is listed. The exact representation depends on how the type is being used.</p>

<ul>
	<li>Nullable arguments become <code>Foo*</code>.</li>
	<li>Non-nullable arguments become <code>Foo&amp;</code>.</li>
	<li>Return values become <code>already_AddRefed&lt;Foo&gt;</code> or <code>Foo*</code> as desired. The pointer form is preferred because it results in faster code, but it should only be used if the return value was not addrefed (and so it can only be used if the return value is kept alive by the callee until at least the binding method has returned).</li>
	<li>WebIDL interfaces in sequences, dictionaries, owning unions, and variadic arguments are represented by <code>RefPtr&lt;Foo&gt;</code> if nullable and <a href="#OwningNonNull"><code>OwningNonNull&lt;Foo&gt;</code></a> otherwise.</li>
</ul>

<p>For example, this WebIDL:</p>

<pre class="notranslate">interface MyInterface {
  attribute MyInterface myAttr;
  void passNullable(MyInterface? arg);
  MyInterface? doSomething(sequence&lt;MyInterface&gt; arg);
  MyInterface doTheOther(sequence&lt;MyInterface?&gt; arg);
  readonly attribute MyInterface? nullableAttr;
  readonly attribute MyInterface someOtherAttr;
  readonly attribute MyInterface someYetOtherAttr;
};
</pre>

<p>Would correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">already_AddRefed&lt;MyClass&gt; MyAttr();
void SetMyAttr(MyClass&amp; value);
void PassNullable(MyClass* arg);
already_AddRefed&lt;MyClass&gt; doSomething(const Sequence&lt;OwningNonNull&lt;MyClass&gt; &gt;&amp; arg);
already_AddRefed&lt;MyClass&gt; doTheOther(const Sequence&lt;RefPtr&lt;MyClass&gt; &gt;&amp; arg);
already_Addrefed&lt;MyClass&gt; GetNullableAttr();
MyClass* SomeOtherAttr();
MyClass* SomeYetOtherAttr(); // Don&apos;t have to return already_AddRefed!
</pre>

<h5 id="SpiderMonkey_interfaces">&quot;SpiderMonkey&quot; interfaces</h5>

<p>Typed array, array buffer, and array buffer view arguments are represented by the objects in <a href="#TypedArray" title="#TypedArray"><code>TypedArray.h</code></a>.  For example, this WebIDL:</p>

<pre class="notranslate">interface Test {
  void passTypedArrayBuffer(ArrayBuffer arg);
  void passTypedArray(ArrayBufferView arg);
  void passInt16Array(Int16Array? arg);
}
</pre>

<p>will correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">void PassTypedArrayBuffer(const ArrayBuffer&amp; arg);
void PassTypedArray(const ArrayBufferView&amp; arg);
void PassInt16Array(const Nullable&lt;Int16Array&gt;&amp; arg);
</pre>

<p>Typed array return values become a <code>JS::MutableHandle&lt;JSObject*&gt;</code> out param appended to the argument list. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.  The return value is allowed to be in any compartment; bindings will wrap it into the context compartment as needed.</p>

<p>Typed arrays store a <code>JSObject*</code> and hence need to be rooted properly.  On-stack typed arrays can be declared as <code>RootedTypedArray&lt;TypedArrayType&gt;</code> (e.g. <code>RootedTypedArray&lt;Int16Array&gt;</code>).  Typed arrays on the heap need to be traced.</p>

<h4 id="Dictionary_types">Dictionary types</h4>

<p>A dictionary argument is represented by a const reference to a struct whose name is the dictionary name in the <code>mozilla::dom</code> namespace.  The struct has one member for each of the dictionary&apos;s members with the same name except the first letter uppercased and prefixed with &quot;m&quot;. The members that are required or have default values have types as described under the corresponding WebIDL type in this document. The members that are not required and don&apos;t have default values have those types wrapped in <a href="#Optional" title="#Optional"><code>Optional&lt;&gt;</code></a>.</p>

<p>Dictionary return values are represented by an out parameter whose type is a non-const reference to the struct described above, with all the members that have default values preinitialized to those default values.</p>

<p>Note that optional dictionary arguments are always forced to have a default value of an empty dictionary by the IDL parser and code generator, so dictionary arguments are never wrapped in <code>Optional&lt;&gt;</code>.</p>

<p>If necessary, dictionaries can be directly initialized from a <code>JS::Value</code> in C++ code by invoking their <code>Init()</code> method. Consumers doing this should declare their dictionary as <code>RootedDictionary&lt;DictionaryName&gt;</code>. When this is done, passing in a null <code>JSContext*</code> is allowed if the passed-in <code>JS::Value</code> is <code>JS::NullValue()</code>. Likewise, a dictionary struct can be converted to a <code>JS::Value</code> in C++ by calling <code>ToJSValue</code> with the dictionary as the second argument. If <code>Init()</code> or <code>ToJSValue()</code> returns false, they will generally set a pending exception on the JSContext; reporting those is the responsibility of the caller.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">dictionary Dict {
  long foo = 5;
  DOMString bar;
};

interface Test {
  void initSomething(optional Dict arg = {});
};
</pre>

<p>will correspond to this C++ function declaration:</p>

<pre class="brush: cpp notranslate">void InitSomething(const Dict&amp; arg);
</pre>

<p>and the <code>Dict</code> struct will look like this:</p>

<pre class="brush: cpp notranslate">struct Dict {
  bool Init(JSContext* aCx, JS::Handle&lt;JS::Value&gt; aVal, const char* aSourceDescription = &quot;value&quot;);

  Optional&lt;nsString&gt; mBar;
  int32_t mFoo;
}
</pre>

<p>Note that the dictionary members are sorted in the struct in alphabetical order.</p>

<h5 id="API_for_working_with_dictionaries">API for working with dictionaries</h5>

<p>There are a few useful methods found on dictionaries and dictionary members that you can use to quickly determine useful things.</p>

<ul>
	<li><strong>member.WasPassed()</strong> - as the name suggests, was a particular member passed?<br>
	(e.g., <code>if (arg.foo.WasPassed() { /* do nice things!*/ }</code>)</li>
	<li><strong>dictionary.IsAnyMemberPresent() </strong>- great for checking if you need to do anything.<br>
	(e.g., <code>if (!arg.IsAnyMemberPresent()) return; // nothing to do</code>)  </li>
	<li><strong>member.Value()  </strong>- getting the actual data/value of a member that was passed.<br>
	(e.g.,  <code>mBar.Assign(args.mBar.value())</code>)</li>
</ul>

<p>Example implementation using all of the above:</p>

<pre class="brush: cpp notranslate">void
MyInterface::InitSomething(const Dict&amp; aArg){
  if (!aArg.IsAnyMemberPresent()) {
    return; // nothing to do!
  }
  if (aArg.mBar.WasPassed() &amp;&amp; !mBar.Equals(aArg.mBar.value())) {
    mBar.Assign(aArg.mBar.Value());
  }
}
</pre>

<h4 id="Enumeration_types">Enumeration types</h4>

<p>WebIDL enumeration types are represented as C++ enum classes. The values of the C++ enum are named by taking the strings in the WebIDL enumeration, replacing all non-alphanumerics with underscores, and uppercasing the first letter, with a special case for the empty string, which becomes the value <code>_empty</code>.</p>

<p>For a WebIDL enum named <code>MyEnum</code>, the C++ enum is named <code>MyEnum</code> and placed in the <code>mozilla::dom</code> namespace, while the values are placed in the <code>mozilla::dom::MyEnum</code> namespace. There is also a <code>mozilla::dom::MyEnumValues::strings</code> which is an array of <code>mozilla::dom::EnumEntry</code> structs that gives access to the string representations of the values.</p>

<p>The type of the enum class is automatically selected to be the smallest unsigned integer type that can hold all the values.  In practice, this is always uint8_t, because WebIDL enums tend to not have more than 255 values.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">enum MyEnum {
  &quot;something&quot;,
  &quot;something-else&quot;,
  &quot;&quot;,
  &quot;another&quot;
};
</pre>

<p>would lead to this C++ enum declaration:</p>

<pre class="brush: cpp notranslate">enum class MyEnum : uint8_t {
  Something,
  Something_else,
  _empty,
  Another
};

namespace MyEnumValues {
extern const EnumEntry strings[10];
} // namespace MyEnumValues
</pre>

<h4 id="Callback_function_types">Callback function types</h4>

<p>Callback functions are represented as an object, inheriting from <a href="#CallbackFunction" title="#CallbackFunction"><code>mozilla::dom::CallbackFunction</code></a>, whose name, in the <code>mozilla::dom</code> namespace, matches the name of the callback function in the WebIDL. If the type is nullable, a pointer is passed in; otherwise a reference is passed in.</p>

<p>The object exposes two <code>Call</code> methods, which both invoke the underlying JS callable. The first <code>Call</code> method has the same signature as a throwing method declared just like the callback function, with an additional trailing &quot;<code>mozilla::dom::CallbackObject::ExceptionHandling</code> <code>aExceptionHandling</code>&quot; argument, defaulting to <code>eReportExceptions</code>, and calling it will invoke the callable with <code>undefined</code> as the <code>this</code> value. The second <code>Call</code> method allows passing in an explicit <code>this</code> value as the first argument. This second call method is a template on the type of the first argument, so the <code>this</code> value can be passed in in whatever form is most convenient, as long as it&apos;s either a type that can be wrapped by XPConnect or a WebIDL interface type.</p>

<p>If <code>aReportExceptions</code> is set to <code>eReportExceptions</code>, the <code>Call</code> methods will report JS exceptions before returning.  If <code>aReportExceptions</code> is set to <code>eRethrowExceptions</code>, JS exceptions will be stashed in the <code>ErrorResult</code> and will be reported when the stack unwinds to wherever the <code>ErrorResult</code> was set up.</p>

<p>For example, this WebIDL:</p>

<pre class="notranslate">callback MyCallback = long (MyInterface arg1, boolean arg2);
interface MyInterface {
  attribute MyCallback foo;
  attribute MyCallback? bar;
};</pre>

<p>will lead to this C++ class declaration, in the <code>mozilla::dom</code> namespace:</p>

<pre class="brush: cpp notranslate">class MyCallback : public CallbackFunction
{
public:
  int32_t
  Call(MyInterface&amp; arg1, bool arg2, ErrorResult&amp; rv,
       ExceptionHandling aExceptionHandling = eReportExceptions);

  template&lt;typename T&gt;
  int32_t
  Call(const T&amp; thisObj, MyInterface&amp; arg1, bool arg2, ErrorResult&amp; rv,
       ExceptionHandling aExceptionHandling = eReportExceptions);
};</pre>

<p>and these C++ function declarations in the <code>MyInterface</code> class:</p>

<pre class="notranslate">already_AddRefed&lt;MyCallback&gt; GetFoo();
void SetFoo(MyCallback&amp;);
already_AddRefed&lt;MyCallback&gt; GetBar();
void SetBar(MyCallback*);
</pre>

<p>A consumer of MyCallback would be able to use it like this:</p>

<pre class="brush: cpp notranslate">void
SomeClass::DoSomethingWithCallback(MyCallback&amp; aCallback, MyInterface&amp; aInterfaceInstance)
{
  ErrorResult rv;
  int32_t number = aCallback.Call(aInterfaceInstance, false, rv);
  if (rv.Failed()) {
    // The error has already been reported to the JS console; you can handle
    // things however you want here.
    return;
  }

  // Now for some reason we want to catch and rethrow exceptions from the callback,
  // and use &quot;this&quot; as the this value for the call to JS.
  number = aCallback.Call(*this, true, rv, eRethrowExceptions);
  if (rv.Failed()) {
    // The exception is now stored on rv.  This code MUST report
    // it usefully; otherwise it will assert.
  }
}
</pre>

<h5 id="sect1"></h5>

<h4 id="Sequences">Sequences</h4>

<p>Sequence arguments are represented by <a href="#Sequence" title="#Sequence"><code>const Sequence&lt;T&gt;&amp;</code></a>, where <code>T</code> depends on the type of elements in the WebIDL sequence.</p>

<p>Sequence return values are represented by an <code>nsTArray&lt;T&gt;</code> out param appended to the argument list, where <code>T</code> is the return type for the elements of the WebIDL sequence. This comes after all IDL arguments, but before the <code>ErrorResult&amp;</code>, if any, for the method.</p>

<h4 id="Arrays">Arrays</h4>

<p>IDL array objects are not supported yet. The spec on these is likely to change drastically anyway.</p>

<h4 id="Union_types">Union types</h4>

<p>Union types are reflected as a struct in the <code>mozilla::dom</code> namespace. There are two kinds of union structs: one kind does not keep its members alive (is &quot;non-owning&quot;), and the other does (is &quot;owning&quot;). Const references to non-owning unions are used for plain arguments. Owning unions are used in dictionaries, sequences, and for variadic arguments. Union return values become a non-const owning union out param. The name of the struct is the concatenation of the names of the types in the union, with &quot;Or&quot; inserted between them, and for an owning struct &quot;Owning&quot; prepended. So for example, this IDL:</p>

<pre class="notranslate">void passUnion((object or long) arg);
(object or long) receiveUnion();
void passSequenceOfUnions(sequence&lt;(object or long)&gt; arg);
void passOtherUnion((HTMLDivElement or ArrayBuffer or EventInit) arg);
</pre>

<p>would correspond to these C++ function declarations:</p>

<pre class="brush: cpp notranslate">void PassUnion(const ObjectOrLong&amp; aArg);
void ReceiveUnion(OwningObjectObjectOrLong&amp; aArg);
void PassSequenceOfUnions(const Sequence&lt;OwningObjectOrLong&gt;&amp; aArg);
void PassOtherUnion(const HTMLDivElementOrArrayBufferOrEventInit&amp; aArg);
</pre>

<p>Union structs expose accessors to test whether they&apos;re of a given type and to get hold of the data of that type. They also expose setters that set the union as being of a particular type and return a reference to the union&apos;s internal storage where that type could be stored. The one exception is the <code>object</code> type, which uses a somewhat different form of setter where the <code>JSObject*</code> is passed in directly. For example, <code>ObjectOrLong</code> would have the following methods:</p>

<pre class="brush: cpp notranslate">bool IsObject() const;
JSObject* GetAsObject() const;
void SetToObject(JSContext*, JSObject*);
bool IsLong() const;
int32_t GetAsLong() const;
int32_t&amp; SetAsLong()
</pre>

<p>Owning unions used on the stack should be declared as a <code>RootedUnion&lt;UnionType&gt;</code>, for example, <code>RootedUnion&lt;OwningObjectOrLong&gt;</code>.</p>

<h4 id="Date"><code>Date</code></h4>

<p>WebIDL <code>Date</code> types are represented by a <code>mozilla::dom::Date</code> struct.</p>

<h3 id="C_reflections_of_WebIDL_declarations">C++ reflections of WebIDL declarations</h3>

<p>WebIDL declarations (maplike/setlike/iterable) are turned into a set of properties and functions on the interface they are declared on. Each has a different set of helper functions it comes with. In addition, for iterable, there are requirements for C++ function implementation by the interface developer.</p>

<h4 id="Maplike">Maplike</h4>

<p>Example Interface:</p>

<pre class="notranslate">interface StringToLongMap {
  maplike&lt;DOMString, long&gt;;
};</pre>

<p>The bindings for this interface will generate the storage structure for the map, as well as helper functions for accessing that structure from C++. The generated C++ API will look as follows:</p>

<pre class="brush: cpp notranslate">namespace StringToLongMapBinding {
namespace MaplikeHelpers {
void Clear(mozilla::dom::StringToLongMap* self, ErrorResult&amp; aRv);
bool Delete(mozilla::dom::StringToLongMap* self, const nsAString&amp; aKey, ErrorResult&amp; aRv);
bool Has(mozilla::dom::StringToLongMap* self, const nsAString&amp; aKey, ErrorResult&amp; aRv);
void Set(mozilla::dom::StringToLongMap* self, const nsAString&amp; aKey, int32_t aValue, ErrorResult&amp; aRv);
} // namespace MaplikeHelpers
} // namespace StringToLongMapBindings

</pre>

<h4 id="Setlike">Setlike</h4>

<p>Example Interface:</p>

<pre class="notranslate">interface StringSet {
  setlike&lt;DOMString&gt;;
};
</pre>

<p>The bindings for this interface will generate the storage structure for the set, as well as helper functions for accessing that structure from c++. The generated C++ API will look as follows:</p>

<pre class="brush: cpp notranslate">namespace StringSetBinding {
namespace SetlikeHelpers {
void Clear(mozilla::dom::StringSet* self, ErrorResult&amp; aRv);
bool Delete(mozilla::dom::StringSet* self, const nsAString&amp; aKey, ErrorResult&amp; aRv);
bool Has(mozilla::dom::StringSet* self, const nsAString&amp; aKey, ErrorResult&amp; aRv);
void Add(mozilla::dom::StringSet* self, const nsAString&amp; aKey, ErrorResult&amp; aRv);
} // namespace SetlikeHelpers
}
</pre>

<h4 id="Iterable">Iterable</h4>

<p>Unlike maplike and setlike, iterable does not have any C++ helpers, as the structure backing the iterable data for the interface is left up to the developer. With that in mind, the generated iterable bindings expect the wrapper object to provide certain methods for the interface to access.</p>

<p>Iterable interfaces have different requirements, based on if they are single or pair value iterators.</p>

<p>Example Interface for a single value iterator:</p>

<pre class="notranslate">interface LongIterable {
  iterable&lt;long&gt;;
  getter long(unsigned long index);
  readonly attribute unsigned long length;
};</pre>

<p>For single value iterator interfaces, we treat the interface as an <a href="#Indexed_getters">indexed getter</a>, as required by the spec. See the <a href="#Indexed_getters">indexed getter implementation section</a> for more information on building this kind of structure.</p>

<p>Example Interface for a pair value iterator:</p>

<pre class="notranslate">interface StringAndLongIterable {
  iterable&lt;DOMString, long&gt;;
};</pre>

<p>The bindings for this pair value iterator interface require the following methods be implemented in the C++ object:</p>

<pre class="brush: cpp notranslate">class StringAndLongIterable {
public:
  // Returns the number of items in the iterable storage
  size_t GetIterableLength();
  // Returns key of pair at aIndex in iterable storage
  nsAString&amp; GetKeyAtIndex(uint32_t aIndex);
  // Returns value of pair at aIndex in iterable storage
  uint32_t&amp; GetValueAtIndex(uint32_t aIndex);
}
</pre>

<h3 id="Stringifiers">Stringifiers</h3>

<p>Named stringifiers operations in WebIDL will just invoke the corresponding C++ method.</p>

<p>Anonymous stringifiers in WebIDL will invoke the C++ method called <code>Stringify</code>. So, for example, given this IDL:</p>

<pre class="notranslate">interface FirstInterface {
  stringifier;
};

interface SecondInterface {
  stringifier DOMString getStringRepresentation();
};
</pre>

<p>the corresponding C++ would be:</p>

<pre class="notranslate">class FirstInterface {
public:
  void Stringify(nsAString&amp; aResult);
};

class SecondInterface {
public:
  void GetStringRepresentation(nsAString&amp; aResult);
};
</pre>

<h3 id="Legacy_Callers">Legacy Callers</h3>

<p>Only anonymous legacy callers are supported, and will invoke the C++ method called <code>LegacyCall</code>. This will be passed the JS &quot;this&quot; value as the first argument, then the arguments to the actual operation. A <code>JSContext</code> will be passed if any of the operation arguments need it. So for example, given this IDL:</p>

<pre class="notranslate">interface InterfaceWithCall {
  legacycaller long (float arg);
};
</pre>

<p>the corresponding C++ would be:</p>

<pre class="brush: cpp notranslate">class InterfaceWithCall {
public:
  int32_t LegacyCall(JS::Handle&lt;JS::Value&gt; aThisVal, float aArgument);
};
</pre>

<h3 id="Named_getters">Named getters</h3>

<p>If the interface has a named getter, the binding will expect several methods on the C++ implementation:</p>

<ul>
	<li>A <code>NamedGetter</code> method. This takes a property name and returns whatever type the named getter is declared to return. It also has a boolean out param for whether a property with that name should exist at all.</li>
	<li> A <code>NameIsEnumerable</code> method. This takes a property name and returns a boolean that indicates whether the property is enumerable.</li>
	<li>A <code>GetSupportedNames</code> method. This takes an unsigned integer which corresponds to the flags passed to the <code>iterate</code> proxy trap and returns a list of property names. For implementations of this method, the important flags is <code>JSITER_HIDDEN</code>. If that flag is set, the call needs to return all supported property names. If it&apos;s not set, the call needs to return only the enumerable ones.</li>
</ul>

<p>The <code>NameIsEnumerable</code> and <code>GetSupportedNames</code> methods need to agree on which names are and are not enumerable. The <code>NamedGetter</code> and <code>GetSupportedNames</code> methods need to agree on which names are supported.</p>

<p>So for example, given this IDL:</p>

<pre class="notranslate">interface InterfaceWithNamedGetter {
  getter long(DOMString arg);
};
</pre>

<p>the corresponding C++ would be:</p>

<pre class="brush: cpp notranslate">class InterfaceWithNamedGetter
{
public:
  int32_t NamedGetter(const nsAString&amp; aName, bool&amp; aFound);
  bool NameIsEnumerable(const nsAString&amp; aName);
  void GetSupportedNames(unsigned aFlags, nsTArray&lt;nsString&gt;&amp; aNames);
};
</pre>

<h3 id="Indexed_getters"><a id="Indexed getters" name="Indexed getters">Indexed getters</a></h3>

<p>If the interface has a indexed getter, the binding will expect the following methods on the C++ implementation:</p>

<ul>
	<li>A <code>IndexedGetter</code> method. This takes an integer index value and returns whatever type the indexed getter is declared to return. It also has a boolean out param for whether a property with that index should exist at all.  The implementation must set this out param correctly.  The return value is guaranteed to be ignored if the out param is set to false.</li>
</ul>

<p>So for example, given this IDL:</p>

<pre class="notranslate">interface InterfaceWithIndexedGetter {
  getter long(unsigned long index);
  readonly attribute unsigned long length;
};
</pre>

<p>the corresponding C++ would be:</p>

<pre class="brush: cpp notranslate">class InterfaceWithIndexedGetter
{
public:
  uint32_t Length() const;
  int32_t IndexedGetter(uint32_t aIndex, bool&amp; aFound) const;
};
</pre>

<h2 id="Throwing_exceptions_from_WebIDL_methods_getters_and_setters">Throwing exceptions from WebIDL methods, getters, and setters</h2>

<p>WebIDL methods, getters, and setters that are <a href="#Throws">explicitly marked as allowed to throw</a> have an <code>ErrorResult&amp;</code> argument as their last argument.  To throw an exception, simply call <code>Throw()</code> on the <code>ErrorResult&amp;</code> and return from your C++ back into the binding code.</p>

<p>In cases when the specification calls for throwing a <code>TypeError</code>, you should use <code>ErrorResult::ThrowTypeError()</code> instead of calling <code>Throw()</code>.</p>

<h2 id="Custom_extended_attributes">Custom extended attributes</h2>

<p>Our WebIDL parser and code generator recognize several extended attributes that are not present in the WebIDL spec.</p>

<h3 id="Alias" name="Alias"><code>[Alias=propName]</code></h3>

<p>This extended attribute can be specified on a method and indicates that another property with the specified name will also appear on the interface prototype object and will have the same Function object value as the property for the method. For example:</p>

<pre class="notranslate">interface MyInterface {
  [Alias=performSomething] void doSomething();
};
</pre>

<p><code>MyInterface.prototype.performSomething</code> will have the same Function object value as <code>MyInterface.prototype.doSomething</code>.</p>

<p>Multiple <code>[Alias]</code> extended attribute can be used on the one method. <code>[Alias]</code> cannot be used on a static method, nor on methods on a global interface (such as <code>Window</code>).</p>

<p>Aside from regular property names, the name of an alias can be <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols">Symbol.iterator</a>. This is specified by writing <code>[Alias=&quot;@@iterator&quot;]</code>.</p>

<h3 id="BindingAlias" name="BindingAlias"><code>[BindingAlias=propName]</code></h3>

<p>This extended attribute can be specified on an attribute and indicates that another property with the specified name will also appear on the interface prototype object and will call the same underlying C++ implementation for the getter and setter. This is more efficient than using the same <code>BinaryName</code> for both attributes, because it shares the binding glue code between them. The properties still have separate getter/setter functions in JavaScript, so from the point of view of web consumers it&apos;s as if you actually had two separate attribute declarations on your interface. For example:</p>

<pre class="notranslate">interface MyInterface {
  [BindingAlias=otherAttr] readonly attribute boolean attr;
};
</pre>

<p><code>MyInterface.prototype.otherAttr</code> and <code>MyInterface.prototype.attr</code> will both exist, have separate getter/setter functions, but call the same binding glue code and implementation function on the objects implementing <code>MyInterface</code>.</p>

<p>Multiple <code>[BindingAlias]</code> extended attributes can be used on a single attribute.</p>

<h3 id="ChromeOnly" name="ChromeOnly"><code>[ChromeOnly]</code></h3>

<p>This extended attribute can be specified on any method, attribute, or constant on an interface or on an interface as a whole.  It can also be specified on dictionary members.</p>

<p>Interface members flagged as <code>[ChromeOnly]</code> are only exposed in chrome Windows (and in particular, are not exposed to webpages). From the point of view of web content, it&apos;s as if the interface member were not there at all. These members <em>are</em> exposed to chrome script working with a content object via Xrays.</p>

<p>If specified on an interface as a whole, this functions like <a href="#Func" title="#Func"><code>[Func]</code></a> except that the binding code will automatically check whether the caller script has the system principal (is chrome or a worker started from a chrome page) instead of calling into the C++ implementation to determine whether to expose the interface object on the global. This means that accessing a content global via Xrays will show <code>[ChromeOnly]</code> interface objects on it.</p>

<p>If specified on a dictionary member, then the dictionary member will only appear to exist in system-privileged code.</p>

<p>This extended attibute can be specified together with <code>[<a href="#Func">Func</a>]</code>,  and <code>[<a href="#Pref">Pref</a>]</code>. If more than one of these is specified, all conditions will need to test true for the interface or interface member to be exposed.</p>

<h3 id="Pref" name="Pref"><code>[Pref=prefname]</code></h3>

<p>This extended attribute can be specified on any method, attribute, or constant on an interface or on an interface as a whole. It can also be specified on dictionary members.  It takes a value, which must be the name of a boolean preference exposed from <code>StaticPrefs</code>. The <code>StaticPrefs</code> function that will be called is calculated from the value of the extended attribute, with dots replaced by underscores (<code>StaticPrefs::my_pref_name()</code> in the example below).</p>

<p>If specified on an interface member, the interface member involved is only exposed if the preference is set to <code>true</code>. An example of how this can be used:</p>

<pre class="notranslate">interface MyInterface {
  attribute long alwaysHere;
  [Pref=&quot;my.pref.name&quot;] attribute long onlyHereIfEnabled;
};
</pre>

<p>If specifed on an interface as a whole, this functions like <a href="#Func" title="#Func"><code>[Func]</code></a> except that the binding will check the value of the preference directly without calling into the C++ implementation of the interface at all. This is useful when the enable check is simple and it&apos;s desirable to keep the prefname with the WebIDL declaration.</p>

<p>If specified on a dictionary member, the web-observable behavior when the pref is set to false will be as if the dictionary did not have a member of that name defined.  That means that on the JS side no observable get of the property will happen.  On the C++ side, the behavior would be as if the passed-in object did not have a property with the relevant name: the dictionary member would either be <code>!Passed()</code> or have the default value if there is a default value.</p>

<p>  An example of how this can be used:</p>

<pre class="notranslate">[Pref=&quot;my.pref.name&quot;]
interface MyConditionalInterface {
};
</pre>

<p>This extended attibute can be specified together with <code>[<a href="#ChromeOnly">ChromeOnly</a>]</code>, and<code>[<a href="#Func">Func</a>]</code>. If more than one of these is specified, all conditions will need to test true for the interface or interface member to be exposed.</p>

<h3 id="Func" name="Func"><code>[Func=&quot;funcname&quot;]</code></h3>

<p>This extended attribute can be specified on any method, attribute, or constant on an interface or on an interface as a whole. It can also be specified on dictionary members.  It takes a value, which must be the name of a static function. </p>

<p>If specified on an interface member, the interface member involved is only exposed if the specified function returns <code>true</code>. An example of how this can be used:</p>

<pre class="notranslate">interface MyInterface {
  attribute long alwaysHere;
  [Func=&quot;MyClass::StuffEnabled&quot;] attribute long onlyHereIfEnabled;
};
</pre>

<p>The function is invoked with two arguments: the <code>JSContext</code> that the operation is happening on and the <code>JSObject</code> for the global of the object that the property will be defined on if the function returns true. In particular, in the Xray case the <code>JSContext</code> is in the caller compartment (typically chrome) but the <code>JSObject</code> is in the target compartment (typically content). This allows the method implementation to select which compartment it cares about in its checks.</p>

<p>The above IDL would also require the following C++:</p>

<pre class="brush: cpp notranslate">class MyClass {
  static bool StuffEnabled(JSContext* cx, JSObject* obj);
};
</pre>

<p>If specified on an interface as a whole, then lookups for the interface object for this interface on a DOM Window will only find it if the specified function returns true. For objects that can only be created via a constructor, this allows disabling the functionality altogether and making it look like the feature is not implemented at all.</p>

<p>If specified on a dictionary member, the web-observable behavior when the function returns false will be as if the dictionary did not have a member of that name defined.  That means that on the JS side no observable get of the property will happen.  On the C++ side, the behavior would be as if the passed-in object did not have a property with the relevant name: the dictionary member would either be <code>!Passed()</code> or have the default value if there is a default value.</p>

<p>An example of how <code>[Func]</code> can be used:</p>

<pre class="notranslate">[Func=&quot;MyClass::MyConditionalInterfaceEnabled&quot;]
interface MyConditionalInterface {
};
</pre>

<p>In this case, the C++ function is passed a <code>JS::Handle&lt;JSObject*&gt;</code>. So the C++ in this case would look like this:</p>

<pre class="brush: cpp notranslate">class MyClass {
  static bool MyConditionalInterfaceEnabled(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj);
};
</pre>

<p>Just like in the interface member case, the <code>JSContext</code> is in the caller compartment but the <code>JSObject</code> is the actual object the property would be defined on. In the Xray case that means obj is in the target compartment (typically content) and <code>cx</code> is typically chrome.</p>

<p>This extended attibute can be specified together with <code>[<a href="#ChromeOnly">ChromeOnly</a>]</code>, and <code>[<a href="#Pref">Pref</a>]</code>. If more than one of these is specified, all conditions will need to test true for the interface or interface member to be exposed.</p>

<p>Binding code will include the headers necessary for a <code>[<a href="#Func">Func</a>]</code>, unless the interface is using a non-deafault heder file.  If a non-default header file is used, that header file needs to do any header inclusions necessary for <code>[<a href="#Func">Func</a>]</code> annotations.</p>

<h3 id="Throws" name="Throws"><code>[Throws]</code>, <code>[GetterThrows]</code>, <code>[SetterThrows]</code></h3>

<p>Used to flag methods or attributes as allowing the C++ callee to throw. This causes the binding generator, and in many cases the JIT, to generate extra code to handle possible exceptions. Possibly-throwing methods and attributes get an <code>ErrorResult&amp;</code> argument.</p>

<p><code>[Throws]</code> applies to both methods and attributes; for attributes it means both the getter and the setter can throw. <code>[GetterThrows]</code> applies only to attributes. <code>[SetterThrows]</code> applies only to non-readonly attributes.</p>

<p>For interfaces flagged with <code>[JSImplementation]</code>, all methods and properties are assumed to be able to throw and do not need to be flagged as throwing.</p>

<h3 id="DependsOn" name="DependsOn"><code>[DependsOn]</code></h3>

<p>Used for a method or attribute to indicate what the return value depends on. Possible values are:</p>

<dl>
	<dt><code>Everything</code></dt>
	<dd>This value can&apos;t actually be specified explicitly; this is the default value you get when <code>[DependsOn]</code> is not specified. This means we don&apos;t know anything about the return value&apos;s dependencies and hence can&apos;t rearrange other code that might change values around the method or attribute.</dd>
	<dt id="DependsOn=DOMState"><code>DOMState</code></dt>
	<dd>The return value depends on the state of the &quot;DOM&quot;, by which we mean all objects specified via Web IDL. The return value is guaranteed to not depend on the state of the JS heap or other JS engine data structures, and is guaranteed to not change unless some function with <a href="#Affects=Everything"><code>[Affects=Everything]</code></a> is executed.</dd>
	<dt><code>DeviceState</code></dt>
	<dd>The return value depends on the state of the device we&apos;re running on (e.g., the system clock). The return value is guaranteed to not be affected by any code running inside Gecko itself, but we might get a new value every time the method or getter is called even if no Gecko code ran between the calls.</dd>
	<dt id="DependsOn=Nothing"><code>Nothing</code></dt>
	<dd>The return value is a constant that never changes. This value cannot be used on non-readonly attributes, since having a non-readonly attribute whose value never changes doesn&apos;t make sense.</dd>
</dl>

<p>Values other than <code>Everything</code>, when used in combination with <a href="#Affects=Nothing"><code>[Affects=Nothing]</code></a>, can used by the JIT to perform loop-hoisting and common subexpression elimination on the return values of IDL attributes and methods.</p>

<h3 id="Affects" name="Affects"><code>[Affects]</code></h3>

<p>Used for a method or attribute getter to indicate what sorts of state can be affected when the function is called. Attribute setters are, for now, assumed to affect everything. Possible values are:</p>

<dl>
	<dt id="Affects=Everything"><code>Everything</code></dt>
	<dd>This value can&apos;t actually be specified explicitly; this is the default value you get when <code>[Affects]</code> is not specified. This means that calling the method or getter might change any mutable state in the DOM or JS heap.</dd>
	<dt id="Affects=Nothing"><code>Nothing</code></dt>
	<dd>Calling the method or getter will have no side-effects on either the DOM or the JS heap.</dd>
</dl>

<p>Methods and attribute getters with <code>[Affects=Nothing]</code> are allowed to throw exceptions, as long as they do so deterministically. In the case of methods, whether an exception is thrown is allowed to depend on the arguments, as long as calling the method with the same arguments will always either throw or not throw.</p>

<p>The <code>Nothing</code> value, when used with <code>[DependsOn]</code> values other than <code>Everything</code>, can used by the JIT to perform loop-hoisting and common subexpression elimination on the return values of IDL attributes and methods, as well as code motion past DOM methods that might depend on system state but have no side effects.</p>

<h3 id="Pure" name="Pure"><code>[Pure]</code></h3>

<p>This is an alias for <code>[<a href="#Affects=Nothing">Affects=Nothing</a>, <a href="#DependsOn=DOMState">DependsOn=DOMState</a>]</code>. Attributes/methods flagged in this way promise that they will keep returning the same value as long as nothing that has <code>[Affects=Everything]</code> executes.</p>

<h3 id="Constant" name="Constant"><code>[Constant]</code></h3>

<p>This is an alias for <code>[<a href="#Affects=Nothing">Affects=Nothing</a>, <a href="#DependsOn=Nothing">DependsOn=Nothing</a>]</code>. Used to flag readonly attributes or methods that could have been annotated with <code>[Pure]</code> and also always return the same value. This should only be used when it&apos;s absolutely guaranteed that the return value of the attribute getter will always be the same from the JS engine&apos;s point of view.</p>

<p>The spec&apos;s <code><a href="https://heycam.github.io/webidl/#SameObject">[SameObject]</a></code> extended attribute is an alias for <code>[Constant]</code>, but can only be applied to things returning objects, whereas <code>[Constant]</code> can be used for any type of return value.</p>

<h3 id="NeedResolve" name="NeedResolve"><code>[NeedResolve]</code></h3>

<p>Used to flag interfaces which have a custom resolve hook. This annotation will cause the <code>DoResolve</code> method to be called on the underlying C++ class when a property lookup happens on the object. The signature of this method is: <code>bool DoResolve(JSContext*, JS::Handle&lt;JSObject*&gt;, JS::Handle&lt;jsid&gt;, JS::MutableHandle&lt;JS::Value&gt;)</code>. Here the passed-in object is the object the property lookup is happening on (which may be an Xray for the actual DOM object) and the jsid is the property name. The value that the property should have is returned in the <code>MutableHandle&lt;Value&gt;</code>, with <code>UndefinedValue()</code> indicating that the property does not exist.</p>

<p>If this extended attribute is used, then the underlying C++ class must also implement a method called <code>GetOwnPropertyNames</code> with the signature <code>void GetOwnPropertyNames(JSContext* aCx, nsTArray&lt;nsString&gt;&amp; aNames, ErrorResult&amp; aRv)</code>. This method will be called by the JS engine&apos;s enumerate hook and must provide a superset of all the property names that <code>DoResolve</code> might resolve. Providing names that <code>DoResolve</code> won&apos;t actually resolve is OK.</p>

<h3 id="HeaderFile" name="HeaderFile"><code>[HeaderFile=&quot;path/to/headerfile.h&quot;]</code></h3>

<p>Indicates where the implementation can be found. Similar to the headerFile annotation in Bindings.conf.  Just like headerFile in Bindings.conf, should be avoided.</p>

<h3 id="JSImplementation" name="JSImplementation"><code>[JSImplementation=&quot;@mozilla.org/some-contractid;1&quot;]</code></h3>

<p>Used on an interface to provide the contractid of the <a href="#Implementing_WebIDL_using_Javascript" title="#Implementing_WebIDL_using_Javascript">JavaScript component implementing the interface</a>.</p>

<h3 id="NavigatorProperty" name="NavigatorProperty"><code>[NavigatorProperty=&quot;propName&quot;]</code></h3>

<p>Setting this extended attribute to <code>propName</code> on an interface causes <code>window.navigator.propName</code> to be an instance of the interface.  Note that adding or removing this extended attribute requires a clobber.  See https://bugzilla.mozilla.org/show_bug.cgi?id=1333117 for details.</p>

<h3 id="StoreInSlot" name="StoreInSlot"><code>[StoreInSlot]</code></h3>

<p>Used to flag attributes that can be gotten very quickly from the JS object by the JIT. Such attributes will have their getter called immediately when the JS wrapper for the DOM object is created, and the returned value will be stored directly on the JS object. Later gets of the attribute will not call the C++ getter and instead use the cached value. If the value returned by the attribute needs to change, the C++ code should call the <code>ClearCachedFooValue</code> method in the namespace of the relevant binding, where <code>foo</code> is the name of the attribute. This will immediately call the C++ getter and cache the value it returns, so it needs a <code>JSContext</code> to work on. This extended attribute can only be used in on attributes whose getters are <a href="#Pure"><code>[Pure]</code></a> or <a href="#Constant"><code>[Constant]</code></a> and which are not <a href="#Throws"><code>[Throws]</code></a> or <a href="#Throws"><code>[GetterThrows]</code></a>.</p>

<p>So for example, given this IDL:</p>

<pre class="notranslate">interface MyInterface {
  [Pure, StoreInSlot] attribute long myAttribute;
};
</pre>

<p>the C++ implementation of MyInterface would clear the cached value by calling <code>mozilla::dom::MyInterface_Binding::ClearCachedMyAttributeValue(cx, this)</code>. This function will return false on error and the caller is responsible for handling any JSAPI exception that is set by the failure.</p>

<p>If the attribute is not readonly, setting it will automatically clear the cached value and reget it again before the setter returns.</p>

<h3 id="Cached" name="Cached"><code>[Cached]</code></h3>

<p>Used to flag attributes that, when their getter is called, will cache the returned value on the JS object. This can be used to implement attributes whose value is a sequence or dictionary (which would otherwise end up returning a new object each time and hence not be allowed in WebIDL).</p>

<p>Unlike <a href="#StoreInSlot"><code>[StoreInSlot]</code></a> this does <em>not</em> cause the getter to be eagerly called at JS wrapper creation time; the caching is lazy. <code>[Cached]</code> attributes must be <a href="#Pure"><code>[Pure]</code></a> or <a href="#Constant"><code>[Constant]</code></a>, because otherwise not calling the C++ getter would be observable, but are allowed to have throwing getters. Their cached value can be cleared by calling the <code>ClearCachedFooValue</code> method in the namespace of the relevant binding, where <code>foo</code> is the name of the attribute. Unlike <code>[StoreInSlot]</code> attributes, doing so will not immediately invoke the getter, so it does not need a <code>JSContext</code>.</p>

<p>So for example, given this IDL:</p>

<pre class="notranslate">interface MyInterface {
  [Pure, StoreInSlot] attribute long myAttribute;
};
</pre>

<p>the C++ implementation of MyInterface would clear the cached value by calling <code>mozilla::dom::MyInterface_Binding::ClearCachedMyAttributeValue(this)</code>. JS-implemented WebIDL can clear the cached value by calling <code>this.__DOM_IMPL__._clearCachedMyAttributeValue()</code>.</p>

<p>If the attribute is not readonly, setting it will automatically clear the cached value.</p>

<h3 id="Frozen" name="Frozen"><code>[Frozen]</code></h3>

<p>Used to flag attributes that, when their getter is called, will call <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze</code></a> on the return value before returning it. This extended attribute is only allowed on attributes that return sequences, dictionaries and <code>MozMap</code>, and corresponds to returning a frozen <code>Array</code> (for the sequence case) or <code>Object</code> (for the other two cases).</p>

<h3 id="BinaryName" name="BinaryName"><code>[BinaryName]</code></h3>

<p><code>[BinaryName]</code> can be specified on method or attribute to change the C++ function name that will be used for the method or attribute. It takes a single string argument, which is the name you wish the method or attribute had instead of the one it actually has.</p>

<p>For example, given this IDL:</p>

<pre class="notranslate">interface InterfaceWithRenamedThings {
  [BinaryName=&quot;renamedMethod&quot;]
  void someMethod();
  [BinaryName=&quot;renamedAttribute&quot;]
  attribute long someAttribute;
};
</pre>

<p>the corresponding C++ would be:</p>

<pre class="brush: cpp notranslate">class InterfaceWithRenamedThings
{
public:
  void RenamedMethod();
  int32_t RenamedAttribute();
  void SetRenamedAttribute(int32_t);
};
</pre>

<h3 id="Deprecatedtag"><code>[Deprecated=<em>&quot;tag&quot;</em>]</code></h3>

<p>When deprecating an interface or method, the <code>[Deprecated]</code> annotation causes the WebIDL compiler to insert code that generates deprecation warnings.  This annotation can be added to interface methods or interfaces.  Adding this to an interface causes a warning to be issued the first time the object is constructed, or any static method on the object is invoked.</p>

<p>The complete list of valid deprecation tags is maintained in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/base/nsDeprecatedOperationList.h">nsDeprecatedOperationList.h</a>.  Each new tag requires that a localized string be defined, containing the deprecation message to display.</p>

<h3 id="CrossOriginReadable"><code>[CrossOriginReadable]</code></h3>

<p>Used to flag an attribute that, when read, will not have the same-origin constraint tested: it can be read from a context with a different origin.</p>

<h3 id="CrossOriginWrite"><code>[CrossOriginWrite]</code></h3>

<p>Used to flag an attribute that, when written, will not have the same-origin constraint tested: it can be written from a context with a different origin.</p>

<h3 id="CrossOriginCallable"><code>[CrossOriginCallable]</code></h3>

<p>Used to flag a method that, when called, will not have the same-origin constraint tested: it can be called from a context with a different origin.</p>

<h3 id="SecureContext"><code>[SecureContext]</code></h3>

<p>We implement the <a href="https://heycam.github.io/webidl/#SecureContext">standard extended attribute</a> with a few details specific to Gecko:</p>

<ul>
	<li>System principals are considered secure.</li>
	<li>An extension poking at non-secured DOM objects will see APIs marked with <code>[SecureContext]</code>.</li>
	<li>XPConnect sandboxes doesn&apos;t see <code>[SecureContext]</code> APIs, but this may change in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1273687">bug 1273687</a>.</li>
</ul>

<h3 id="NeedsSubjectPrincipal_GetterNeedsSubjectPrincipal_SetterNeedsSubjectPrincipal"><code>[NeedsSubjectPrincipal]</code>, <code>[GetterNeedsSubjectPrincipal]</code>, <code>[SetterNeedsSubjectPrincipal]</code></h3>

<p>Used to flag a method or an attribute that needs to know the subject principal. This principal will be passed as argument.  If the interface is not exposed on any worker global, the argument will be a <code>nsIPrincipal&amp;</code> because a subject principal is always available in mainthread globals.  If the interface is exposed on some worker global, the argument will be a <code>const Maybe&lt;nsIPrincipal*&gt;&amp;</code>. This <code>Maybe&lt;&gt;</code> object contains the principal <em>only</em> on the main thread; when the method is called on a <a href="/en-US/docs/Web/API/Worker"><code>Worker</code></a> thread, the value of the object will be <code>Nothing()</code>.  Note that, in workers, it is always possible to retrieve the correct subject principal from the <code>WorkerPrivate</code> object, though it cannot be used on the worker thread.</p>

<p><code>[NeedsSubjectPrincipal]</code> applies to both methods and attributes; for attributes it means both the getter and the setter need a subject principal. <code>[GetterNeedsSubjectPrincipal]</code> applies only to attributes. <code>[SetterNeedsSubjectPrincipal]</code> applies only to non-readonly attributes.</p>

<h3 id="NeedsCallerType"><code>[NeedsCallerType]</code></h3>

<p>Used to flag a method or an attribute that needs to know the caller type, in the <code>mozilla::dom::CallerType</code> sense.  This can be safely used for APIs exposed in workers; there it will indicate whether the worker involved is a <code>ChromeWorker</code> or not.  At the momen the only possible caller types are <code>System</code> (representing system-principal callers) and <code>NonSystem</code>.</p>

<h2 id="Helper_objects">Helper objects</h2>

<p>The C++ side of the bindings uses a number of helper objects.</p>

<h3 id="Nullable" name="Nullable"><code>Nullable&lt;T&gt;</code></h3>

<p><code>Nullable&lt;&gt;</code> is a struct declared in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/Nullable.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/Nullable.h"><code>Nullable.h</code></a> and exported to <code>mozilla/dom/Nullable.h</code> that is used to represent nullable values of types that don&apos;t have a natural way to represent null.</p>

<p><code>Nullable&lt;T&gt;</code> has an <code>IsNull()</code> getter that returns whether null is represented and a <code>Value()</code> getter that returns a <code>const T&amp;</code> and can be used to get the value when it&apos;s not null.</p>

<p><code>Nullable&lt;T&gt;</code> has a <code>SetNull()</code> setter that sets it as representing null and two setters that can be used to set it to a value: <code>&quot;void SetValue(T)&quot;</code> (for setting it to a given value) and <code>&quot;T&amp; SetValue()&quot;</code> for directly modifying the underlying <code>T&amp;</code>.</p>

<h3 id="Optional" name="Optional"><code>Optional&lt;T&gt;</code></h3>

<p><code>Optional&lt;&gt;</code> is a struct declared in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingDeclarations.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingUtils.h"><code>BindingDeclarations.h</code></a> and exported to <code>mozilla/dom/BindingDeclarations.h</code> that is used to represent optional arguments and dictionary members, but only those that have no default value.</p>

<p><code>Optional&lt;T&gt;</code> has a <code>WasPassed()</code> getter that returns true if a value is available. In that case, the <code>Value()</code> getter can be used to get a <code>const T&amp;</code> for the value.</p>

<h3 id="NonNull" name="NonNull"><code>NonNull&lt;T&gt;</code></h3>

<p><code>NonNull&lt;T&gt;</code> is a struct declared in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingUtils.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingUtils.h"><code>BindingUtils.h</code></a> and exported to <code>mozilla/dom/BindingUtils.h</code> that is used to represent non-null C++ objects. It has a conversion operator that produces <code>T&amp;</code>.</p>

<h3 id="OwningNonNull" name="OwningNonNull"><code>OwningNonNull&lt;T&gt;</code></h3>

<p><code>OwningNonNull&lt;T&gt;</code> is a struct declared in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/xpcom/base/OwningNonNull.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingUtils.h"><code>OwningNonNull.h</code></a> and exported to <code>mozilla/OwningNonNull.h</code> that is used to represent non-null C++ objects and holds a strong reference to them. It has a conversion operator that produces <code>T&amp;</code>.</p>

<h3 id="TypedArrays" name="TypedArrays">Typed arrays, arraybuffers, array buffer views</h3>

<p><code><a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/TypedArray.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/TypedArray.h">TypedArray.h</a></code> is exported to <code>mozilla/dom/TypedArray.h</code> and exposes structs that correspond to the various typed array types, as well as <code>ArrayBuffer</code> and <code>ArrayBufferView</code>, all in the <code>mozilla::dom</code> namespace. Each struct has a <code>Data()</code> method that returns a pointer to the relevant type (<code>uint8_t</code> for <code>ArrayBuffer</code> and <code>ArrayBufferView</code>) and a <code>Length()</code> method that returns the length in units of <code>*Data()</code>. So for example, <code>Int32Array</code> has a <code>Data()</code> returning i<code>nt32_t</code><code>*</code> and a <code>Length()</code> that returns the number of 32-bit ints in the array..</p>

<h3 id="Sequence" name="Sequence"><code>Sequence&lt;T&gt;</code></h3>

<p><code>Sequence&lt;&gt;</code> is a type declared in <a class="external" href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingDeclarations.h" title="http://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingUtils.h"><code>BindingDeclarations.h</code></a> and exported to <code>mozilla/dom/BindingDeclarations.h</code> that is used to represent sequence arguments. It&apos;s some kind of typed array, but which exact kind is opaque to consumers. This allows the binding code to change the exact definition (e.g., to use auto arrays of different sizes and so forth) without having to update all the callees.</p>

<h3 id="CallbackFunction" name="CallbackFunction"><code>CallbackFunction</code></h3>

<p><code>CallbackFunction</code> is a type declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/CallbackFunction.h">CallbackFunction.h</a> and exported to <code>mozilla/dom/CallbackFunction.h</code> that is used as a common base class for all the generated callback function representations. This class inherits from <code>nsISupports</code>, and consumers must make sure to cycle-collect it, since it keeps JS objects alive.</p>

<h3 id="CallbackInterface" name="CallbackInterface"><code>CallbackInterface</code></h3>

<p><code>CallbackInterface</code> is a type declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/CallbackInterface.h">CallbackInterface.h</a> and exported to <code>mozilla/dom/CallbackInterface.h</code> that is used as a common base class for all the generated callback interface representations. This class inherits from <code>nsISupports</code>, and consumers must make sure to cycle-collect it, since it keeps JS objects alive.</p>

<h3 id="DOMString-helper" name="DOMString-helper"><code>DOMString</code></h3>

<p><code>DOMString</code> is a class declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingDeclarations.h">BindingDeclarations.h</a> and exported to <code>mozilla/dom/BindingDeclarations.h</code> that is used for WebIDL <code>DOMString</code> return values. It has a conversion operator to <code>nsString&amp;</code> so that it can be passed to methods that take that type or <code>nsAString&amp;</code>, but callees that care about performance, have an <code>nsStringBuffer</code> available, and promise to hold on to the <code>nsStringBuffer</code> at least until the binding code comes off the stack can also take a <code>DOMString</code> directly for their string return value and call its <code>SetStringBuffer</code> method with the <code>nsStringBuffer</code> and its length. This allows the binding code to avoid extra reference-counting of the string buffer in many cases, and allows it to take a faster codepath even if it does end up having to addref the <code>nsStringBuffer</code>.</p>

<h3 id="GlobalObject" name="GlobalObject"><code>GlobalObject</code></h3>

<p><code>GlobalObject</code> is a class declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingDeclarations.h">BindingDeclarations.h</a> and exported to <code>mozilla/dom/BindingDeclarations.h</code> that is used to represent the global object for static attributes and operations (including constructors). It has a <code>Get()</code> method that returns the <code>JSObject*</code>  for the global and a <code>GetAsSupports()</code> method that returns an <code>nsISupports*</code> for the global on the main thread, if such is available. It also has a <code>Context()</code> method that returns the <code>JSContext*</code> the call is happening on. A caveat: the compartment of the <code>JSContext</code> may not match the compartment of the global!</p>

<h3 id="Date-struct" name="Date-struct"><code>Date</code></h3>

<p><code>Date</code> is a class declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/BindingDeclarations.h">BindingDeclarations.h</a> and exported to <code>mozilla/dom/BindingDeclarations.h</code> that is used to represent WebIDL Dates. It has a <code>TimeStamp()</code> method returning a double which represents a number of milliseconds since the epoch, as well as <code>SetTimeStamp()</code> methods that can be used to initialize it with a double timestamp or a JS <code>Date</code> object. It also has a <code>ToDateObject()</code> method that can be used to create a new JS <code>Date</code>.</p>

<h3 id="ErrorResult" name="ErrorResult"><code>ErrorResult</code></h3>

<p><code>ErrorResult</code> is a class declared in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/ErrorResult.h">ErrorResult.h</a> and exported to <code>mozilla/ErrorResult.h</code> that is used to represent exceptions in WebIDL bindings. This has the following methods:</p>

<ul>
	<li><code>Throw</code>: allows throwing an <code>nsresult</code>. The <code>nsresult</code> must be a failure code.</li>
	<li><code>ThrowTypeError</code>: allows throwing a <code>TypeError</code> with the given error message. The list of allowed <code>TypeError</code>s and corresponding messages is in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/bindings/Errors.msg"><code>dom/bindings/Errors.msg</code></a>.</li>
	<li><code>ThrowJSException</code>: allows throwing a preexisting JS exception value. However, the <code>MightThrowJSException()</code> method must be called before any such exceptions are thrown (even if no exception is thrown).</li>
	<li><code>Failed</code>: checks whether an exception has been thrown on this <code>ErrorResult</code>.</li>
	<li><code>ErrorCode</code>: returns a failure <code>nsresult</code> representing (perhaps incompletely) the state of this <code>ErrorResult</code>.</li>
	<li><code>operator=</code>: takes an <code>nsresult</code> and acts like <code>Throw</code> if the result is an error code, and like a no-op otherwise (unless an exception has already been thrown, in which case it asserts). This should only be used for legacy code that has nsresult everywhere; we would like to get rid of this operator at some point.</li>
</ul>

<h2 id="Events">Events</h2>

<p>Simple <code>Event</code> interfaces can be automatically generated by adding the interface file to GENERATED_EVENTS_WEBIDL_FILES in the appropriate dom/webidl/moz.build file. You can also take a simple generated C++ file pair and use it to build a more complex event (i.e., one that has methods).   </p>

<h3 id="Event_handler_attributes">Event handler attributes</h3>

<p>A lot of interfaces define event handler attributes, like:</p>

<pre class="notranslate">attribute EventHandler onthingchange;</pre>

<p>If you need to implement an event handler attribute for an interface, in the definition (header file), you use the handy &quot;IMPL_EVENT_HANDLER&quot; macro:</p>

<pre class="notranslate">IMPL_EVENT_HANDLER(onthingchange);</pre>

<p>The &quot;onthingchange&quot; needs to be added to the StaticAtoms.py file:</p>

<pre class="notranslate">Atom(&quot;onthingchange&quot;, &quot;onthingchange&quot;)</pre>

<p>The actual implementation (.cpp) for firing the event would then look something like:</p>

<pre class="notranslate">nsresult
MyInterface::DispatchThingChangeEvent()
{
   NS_NAMED_LITERAL_STRING(type, &quot;thingchange&quot;);
   EventInit init;
   init.mBubbles = false;
   init.mCancelable = false;
   RefPtr&lt;Event&gt; event = Event::Constructor(this, type, init);
   event-&gt;SetTrusted(true);
   ErrorResult rv;
   DispatchEvent(*event, rv);
   return rv.StealNSResult();  // Assuming the caller cares about the return code.
}
</pre>

<h2 id="Bindings.conf" name="Bindings.conf"><code>Bindings.conf</code> details</h2>

<p>Write me. In particular, need to describe at least use of <code>concrete</code>, <code>prefable</code>, and <code>addExternalInterface</code>.</p>

<h3 id="How_to_get_a_JSContext_passed_to_a_given_method">How to get a JSContext passed to a given method</h3>

<p>In some rare cases you may need a <code>JSContext*</code> argument to be passed to a C++ method that wouldn&apos;t otherwise get such an argument. To see how to achieve this, search for <code>implicitJSContext</code> in <a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#Bindings.conf" title="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings#Bindings.conf">dom/bindings/Bindings.conf</a>.</p>

<h2 id="Implementing_WebIDL_using_Javascript">Implementing WebIDL using Javascript</h2>

<p>It is possible to implement WebIDL interfaces in JavaScript within Gecko -- however, <strong>this is limited to interfaces that are not exposed in Web Workers</strong>. When the binding occurs, two objects are created:</p>

<ul>
	<li><em>Content-exposed object:</em> what gets exposed to the web page.</li>
	<li><em>Implementation object:</em> running as a chrome-privileged script. This allows the implementation object to have various APIs that the content-exposed object does not.</li>
</ul>

<p>Because there are two types of objects, you have to be careful about which object you are creating.</p>

<h3 id="Creating_JS-implemented_WebIDL_objects">Creating JS-implemented WebIDL objects</h3>

<p>To create a JS-implemented WebIDL object, one must create both the chrome-side implementation object and the content-side page-exposed object. There are three ways to do this.</p>

<h4 id="Using_the_WebIDL_constructor">Using the WebIDL constructor</h4>

<p>If the interface has a constructor, a content-side object can be created by getting that constructor from the relevant content window and invoking it. For example:</p>

<pre class="brush: js notranslate">var contentObject = new contentWin.RTCPeerConnection();</pre>

<p>The returned object will be an Xray wrapper for the content-side object. Creating the object this way will automatically create the chrome-side object using its contractID.</p>

<p>This method is limited to the constructor signatures exposed to webpages. Any additional configuration of the object needs to be done methods on the interface. </p>

<p>Creating many objects this way can be slow due to the createInstance overhead involved. </p>

<h4 id="Using_a__create_method">Using a <code>_create</code> method  </h4>

<p>A content-side object can be created for a given chrome-side object by invoking the static <code>_create</code> method on the interface. This method takes two arguments: the content window in which to create the object and the chrome-side object to use. For example:</p>

<pre class="brush: js notranslate">                                                       </pre>

<p>However, if you are in a JS component, you may only be able to get to the correct interface object via some window object. In this case, the code would look more like:</p>

<pre class="brush: js notranslate">      </pre>

<p>Creating the object this way will not invoke its <code>__init</code> method or <code>init</code> method.</p>

<h4 id="By_returning_a_chrome-side_object_from_a_JS-implemented_WebIDL_method">By returning a chrome-side object from a JS-implemented WebIDL method</h4>

<p>If a JS-implemented WebIDL method is declared as returning a JS-implemented interface, then a non-WebIDL object returned from that method will be treated as the chrome-side part of a JS-implemented WebIdL object and the content-side part will be automatically created.</p>

<p>Creating the object this way will not invoke its <code>__init</code> method or <code>init</code> method.</p>

<h3 id="Implementing_a_WebIDL_object_in_JavaScript">Implementing a WebIDL object in JavaScript</h3>

<p>To implement a WebIDL interface in JavaScript, first add a WebIDL file, in the same way as you would for a C++-implemented interface. To support implementation in JS, you must add an extended attribute <code>JSImplementation=&quot;CONTRACT_ID_STRING&quot;</code> on your interface, where CONTRACT_ID_STRING is the XPCOM component contract ID of the JS implementation -- note &quot;;1&quot; is just a Mozilla convention for versioning APIs. Here&apos;s an example:</p>

<pre class="notranslate">[Constructor(optional long firstNumber), JSImplementation=&quot;@mozilla.org/my-number;1&quot;]
interface MyNumber {
  attribute long value;
  readonly attribute long otherValue;
  void doNothing();
};</pre>

<p>Next, create an XPCOM component that implements this interface. <a href="/en-US/docs/How_to_Build_an_XPCOM_Component_in_Javascript" title="/en-US/docs/How_to_Build_an_XPCOM_Component_in_Javascript">Basic directions</a> for how to do this can be found elsewhere on MDN. Use the same contract ID as you specified in the WebIDL file. The class ID doesn&apos;t matter, except that it should be a newly generated one. For <code>QueryInterface</code>, you only need to implement <code>nsISupports</code>, not anything corresponding to the WebIDL interface. The name you use for the XPCOM component should be distinct from the name of the interface, to avoid confusing error messages.</p>

<p>WebIDL attributes are implemented as properties on the JS object or its prototype chain, whereas WebIDL methods are implemented as methods on the object or prototype. Note that any other instances of the interface that you are passed in as arguments are the full web-facing version of the object, and not the JS implementation, so you currently cannot access any private data.</p>

<p>The WebIDL constructor invocation will first create your object. If the XPCOM component implements <code>nsIDOMGlobalPropertyInitializer</code><span id="summary_alias_container"><span id="short_desc_nonedit_display">, then the object&apos;s </span></span><code>init</code><span id="summary_alias_container"><span id="short_desc_nonedit_display"> method will be invoked with a single argument: the content window the constructor came from. This allows the JS implementation to know which content window it&apos;s associated with. The </span></span><code>init</code><span id="summary_alias_container"><span id="short_desc_nonedit_display"> method should not return anything. After this, the content-side object will be created. Then, </span></span>if there are any constructor arguments, the object&apos;s <code>__init</code> method will be invoked, with the constructor arguments as its arguments.</p>

<p>If you want an instance of the class to be added to <code>window.navigator</code>, add an extended attribute<span class="difflineplus"> </span><code>NavigatorProperty=&quot;PropertyName&quot;</code> which will make the instance available as <code>window.navigator.PropertyName</code>.  Note that adding or removing <code>NavigatorProperty</code> requires a clobber.  See https://bugzilla.mozilla.org/show_bug.cgi?id=1333117 for details.</p>

<h3 id="Static_Members">Static Members</h3>

<p>Static attributes and methods are not supported on JS-implemented WebIDL (see <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=863952">bug 863952</a>).  However, with the changes in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1172785">bug 1172785</a> you can route static methods to a C++ implementation on another object using a <code>StaticClassOverride</code> annotation.  This annotation includes the full, namespace-qualified name of the class that contains an implementation of the named method.  The include for that class must be found in a directory based on its name.</p>

<pre class="notranslate">[JSImplementation=&quot;@mozilla.org/dom/foo;1&quot;]
interface Foo {
  [StaticClassOverride=&quot;mozilla::dom::OtherClass&quot;]
  static Promise&lt;void&gt; doSomething();
};
</pre>

<p>Rather than calling into a method on the JS implementation; calling <code>Foo.doSomething()</code> will result in calling <code>mozilla::dom::OtherClass::DoSomething()</code>.</p>

<h3 id="Checking_for_Permissions_or_Preferences">Checking for Permissions or Preferences</h3>

<p>With JS-implemented WebIDL, the <code>init</code> method should only return undefined. If any other value, such as <code>null</code>, is returned, the bindings code will assert or crash. In other words, it acts like it has a &quot;void&quot; return type. Preference or permission checking should be implemented by adding an extended attribute to the WebIDL interface. This has the advantage that if the check fails, the constructor or object will not show up at all.</p>

<p>For preference checking, add an extended attribute <code>Pref=&quot;myPref.enabled&quot;</code> where <code>myPref.enabled</code> is the preference that should be checked. <code>SettingsLock</code> is an example of this.</p>

<p>For permissions or other kinds of checking, add an extended attribute <code>Func=&quot;MyPermissionChecker&quot;</code> where <code>MyPermissionChecker</code> is a function implemented in C++ that returns true if the interface should be enabled. This function can do whatever checking is needed. One example of this is <code>PushManager</code>.</p>

<h3 id="Example">Example</h3>

<p>Here&apos;s an example JS implementation of the above interface. The <code>invisibleValue</code> field will not be accessible to web content, but is usable by the doNothing() method.</p>

<pre class="brush: js notranslate">Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);

function MyNumberInner() {
  this.value = 111;
  this.invisibleValue = 12345;
}

MyNumberInner.prototype = {
  classDescription: &quot;Get my number XPCOM Component&quot;,
  classID: Components.ID(&quot;{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}&quot;), // dummy UUID
  contractID: &quot;@mozilla.org/my-number;1&quot;,
  QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsISupports]),
  doNothing: function() {},
  get otherValue() { return this.invisibleValue - 4; },
  __init: function(firstNumber) {
    if (arguments.length &gt; 0) {
      this.value = firstNumber;
    }
  }
}

var components = [MyNumberInner];
var NSGetFactory = XPCOMUtils.generateNSGetFactory(components);</pre>

<p>Finally, add a component and a contract and whatever other manifest stuff you need to implement an XPCOM component.</p>

<h3 id="Guarantees_provided_by_bindings">Guarantees provided by bindings</h3>

<p>When implementing a WebIDL interface in JavaScript, certain guarantees will be provided by the binding implementation. For example, string or numeric arguments will actually be primitive strings or numbers. Dictionaries will contain only the properties that they are declared to have, and they will have the right types. Interface arguments will actually be objects implementing that interface.</p>

<p>What the bindings will NOT guarantee is much of anything about <code>object</code> and <code>any</code> arguments. They will get cross-compartment wrappers that make touching them from chrome code not be an immediate security bug, but otherwise they can have quite surprising behavior if the page is trying to be malicious. Try to avoid using these types if possible.</p>

<h3 id="Accessing_the_content_object_from_the_implementation">Accessing the content object from the implementation</h3>

<p>If the JS implementation of the WebIDL interface needs to access the content object, it is available as a property called <code>__DOM_IMPL__</code> on the chrome implementation object. This property only appears after the content-side object has been created. So it is available in <code>__init</code> but not in <code>init</code>.</p>

<h3 id="MaplikeSetlike_declaration_helpers_in_Javascript_implementations">Maplike/Setlike declaration helpers in Javascript implementations</h3>

<p>In order to manipulate the storage for maplike and setlike declarations on WebIDL interfaces from javascript implementations, certain functions are generated that can be used by the implementation. Retreival from storage can happen via the publically exposed maplike functions for the interface, but these helpers guarentee that access is available to manipulate storage from chrome JS, even in the case of the interface declaration being readonly.</p>

<h4 id="Maplike_2">Maplike</h4>

<p>The following interface:</p>

<pre class="notranslate">[JSImplementation=&quot;@mozilla.org/dom/string-to-long-js-maplike;1&quot;,
 Constructor()]
interface StringToLongMaplike {
  readonly maplike&lt;DOMString, long&gt;;
};
</pre>

<p>Has these JS functions available to it:</p>

<pre class="brush: js notranslate">// Sets a certain key with a certain value. Exception thrown on wrong types.
this.__DOM_IMPL__.__set(aKey, aValue);
// Deletes a key. Returns a boolean, true if key exists and was deleted, false otherwise.
this.__DOM_IMPL__.__delete(aKey);
// Completely clear all values from maplike storage
this.__DOM_IMPL__.__clear();
</pre>

<h4 id="Setlike_2">Setlike</h4>

<p>The following interface:</p>

<pre class="notranslate">[JSImplementation=&quot;@mozilla.org/dom/string-js-setlike;1&quot;,
 Constructor()]
interface StringSetlike {
  readonly setlike&lt;DOMString&gt;;
};
</pre>

<p>Has these JS functions available to it:</p>

<pre class="brush: js notranslate">// Adds a key to a set. Exception thrown on wrong types.
this.__DOM_IMPL__.__add(aKey);
// Deletes a key. Returns a boolean, true if key exists and was deleted, false otherwise.
this.__DOM_IMPL__.__delete(aKey)
// Completely clear all values from maplike storage
this.__DOM_IMPL__.__clear();
</pre>

<h3 id="Determining_the_principal_of_the_caller_that_invoked_the_WebIDL_API">Determining the principal of the caller that invoked the WebIDL API</h3>

<p>This can be done by calling <code>Component.utils.<span class="d">getWebIDLCallerPrincipal</span>()</code>.</p>

<h3 id="Throwing_exceptions_from_JS-implemented_APIs">Throwing exceptions from JS-implemented APIs</h3>

<p>There are two reasons a JS implemented API might throw. The first reason is that some unforeseen condition occurred and the second is that a specification requires an exception to be thrown.</p>

<p>When throwing for an unforeseen condition, the exception will be reported to the console, and a sanitized NS_ERROR_UNEXPECTED exception will be thrown to the calling content script, with the file/line of the content code that invoked your API. This will avoid exposing chrome URIs and other implementation details to the content code.</p>

<p>When throwing because a specification requires an exception, you need to create the exception from the window your WebIDL object is associated with (the one that was passed to your <code>init</code> method). The binding code will then rethrow that exception to the web page.  An example of how this could work:</p>

<pre class="brush: js notranslate">if (!isValid(passedInObject)) {
  throw new this.contentWindow.TypeError(&quot;Object is invalid&quot;);
}
</pre>

<p>or</p>

<pre class="brush: js notranslate">if (!isValid(passedInObject)) {
  throw new this.contentWindow.DOMException(&quot;Object is invalid&quot;, &quot;InvalidStateError&quot;);
}
</pre>

<p>depending on which exact exception the specification calls for throwing in this situation.</p>

<p>In some cases you may need to perform operations whose exception message you just want to propagate to the content caller. This can be done like so:</p>

<pre class="brush: js notranslate">try {
  someOperationThatCanThrow();
} catch (e) {
  throw new this.contentWindow.Error(e.message);
}
</pre>

<h3 id="Inheriting_from_interfaces_implemented_in_C">Inheriting from interfaces implemented in C++</h3>

<p>It&apos;s possible to have an interface implemented in JavaScript inherit from an interface implemented in C++. To do so, simply have one interface inherit from the other and the bindings code will auto-generate a C++ object inheriting from the implementation of the parent interface. The class implementing the parent interface will need a constructor that takes an <code>nsPIDOMWindow*</code> (though it doesn&apos;t have to do anything with that argument).</p>

<p>If the class implementing the parent interface is abstract and you want to use a specific concrete class as the implementation to inherit from, you will need to add a <code>defaultImpl</code> annotation to the descriptor for the parent interface in <code>Bindings.conf</code>. The value of the annotation is the C++ class to use as the parent for JS-implemented descendants; if <code>defaultImpl</code> is not specified, the <code>nativeType</code> will be used.</p>

<p>For example, consider this interface that we wish to implement in JavaScript:</p>

<pre class="notranslate">[<code>JSImplementation</code>=&quot;some-contract&quot;]
interface MyEventTarget : EventTarget {
  attribute EventHandler onmyevent;
  void dispatchTheEvent(); // Sends a &quot;myevent&quot; event to this EventTarget
}
</pre>

<p>The implementation would look something like this, ignoring most of the XPCOM boilerplate:</p>

<pre class="brush: js notranslate">function MyEventTargetImpl() {
}
MyEventTargetImpl.prototype = {
  // QI to nsIDOMGlobalPropertyInitializer so we get init() called on us.
  QueryInterface: XPCOMUtils.generateQI([Ci.nsIDOMGlobalPropertyInitializer]),

  init: function(contentWindow) {
    this.contentWindow = contentWindow;
  },

  get onmyevent() {
    return this.__DOM_IMPL__.getEventHandler(&quot;onmyevent&quot;);
  },

  set onmyevent(handler) {
    this.__DOM_IMPL__.setEventHandler(&quot;onmyevent&quot;, handler);
  },

  dispatchTheEvent: function() {
    var event = new this.contentWindow.Event(&quot;myevent&quot;);
    this.__DOM_IMPL__.dispatchEvent(event);
  },
};
</pre>

<p>The implementation would automatically support the API exposed on <code>EventTarget</code> (so, for example, <code>addEventListener</code>). Calling the <code>dispatchTheEvent</code> method would cause dispatch of an event that content script can see via listeners it has added.</p>

<p>Note that in this case the chrome implementation is relying on some <code>[ChromeOnly]</code> methods on EventTarget that were added specifically to make it possible to easily implement event handlers. Other cases can do similar things as needed.</p>
