---
title: Visione architetturale di insieme
slug: Archive/B2G_OS/Platform/Architecture
tags:
  - Architettura
  - B2G
  - Firefox OS
  - Guida
  - IPC
  - IPDL
translation_of: Archive/B2G_OS/Architecture
---
<div class="summary">
<p><span class="seoSummary">Questo articolo offre una panoramica di alto livello dell&apos;architettura della piattaforma Firefox OS, introducendo concetti chiave e spiegando come le sue componenti interagiscono a livello base.</span></p>
</div>

<div class="note notecard">
<p><strong>Nota:</strong> <span lang="it" id="result_box"><span class="hps">Tieni presente che</span> <span class="hps">Firefox</span> <span class="hps">OS</span> <span class="hps">è ancora un prodotto in</span> <span class="hps">pre-release</span><span>.</span> <span class="hps">L&apos;architettura</span> <span class="hps">qui descritta</span> <span class="hps">non è necessariamente</span> <span class="hps">definitiva</span><span>.</span></span></p>
</div>

<h2 id="Terminologia">Terminologia</h2>

<p><span lang="it" id="result_box"><span class="hps">Seguono alcuni termini che vanno compresi</span><span class="hps"> prima</span> <span class="hps">di procedere oltre con la lettura della </span><span class="hps">documentazione</span>.</span></p>

<dl>
 <dt>B2G</dt>
 <dd>In breve Boot to Gecko.</dd>
 <dt>Boot to Gecko</dt>
 <dd>Il nome in codice del sistema operativo Firefox OS. Vedrai spesso questo termine riferito a Firefox OS, in quanto venne usato a lungo prima che il progetto avesse un nome ufficiale.</dd>
 <dt>Firefox OS</dt>
 <dd>Firefox OS è fondamentalmente Mozilla (e i partner OEM) con i rispettivi brand e servizi di supporto e il sistema<strong> Boot to Gecko</strong>, con l&apos;obiettivo di crearne un prodotto finito.</dd>
 <dt><a href="/it/Firefox_OS/Platform/Gaia" title="/it/Firefox_OS/Platform/Gaia">Gaia</a></dt>
 <dd>
 <div class="almost_half_cell" id="gt-res-content">
 <div style="zoom: 1;" dir="ltr"><span lang="it" id="result_box"><span class="hps">L&apos;interfaccia utente</span> <span class="hps">della piattaforma</span> <span class="hps">Firefox</span> <span class="hps">OS</span><span>.</span> <span class="hps">Ogni oggetto rappresentato sullo schermo, dopo aver avviato</span> <span class="hps">Firefox</span> <span class="hps">OS</span>, viene gestito dallo strato di Gaia<span>.</span> <span class="hps">Gaia</span> <span class="hps">implementa</span> <span class="hps">la schermata di</span> <span class="hps">blocco, la schermata iniziale</span><span>,</span> <span class="hps">e tutte le</span> <span class="hps">applicazioni standard</span> <span class="hps">che ci si aspetta</span> <span class="hps">in</span> <span class="hps">un moderno smartphone</span><span>.</span> <span class="hps">Gaia</span> <span class="hps">è implementato</span> <span class="hps">interamente con</span> <span class="hps">HTML</span><span>, CSS e</span> <span class="hps">JavaScript</span><span>.</span> <span class="hps">Le sue</span> <span class="hps">uniche interfacce</span> <span class="hps">al sistema</span> <span class="hps">operativo sottostante</span> <span class="hps">sono attraverso</span> <span class="hps">le open Web API.</span> <span class="hps">implementate dallo strato di Gecko. </span><span class="hps">Applicazioni di terze parti</span> <span class="hps">possono essere installate</span> attraverso <span class="hps">Gaia</span><span>.</span></span></div>
 </div>
 </dd>
 <dt><a href="/it/docs/Gecko" title="/it/docs/Gecko">Gecko</a></dt>
 <dd>È l’ambiente di esecuzione delle app di Firefox OS; cioè, lo strato che fornische tutto il supporto per gli standard HTML, CSS e JavaScript. Garantisce che tutte le API siano correttamente funzionanti su ogni sistema operativo supportato da Gecko. Questo significa che Gecko include, fra l&apos;altro, uno stack di rete, uno grafico, un motore che realizza il layout del contenuto, una macchina virtuale per l’esecuzione di codice JavaScript e livelli di portabilità per differenti piattaforme.</dd>
 <dt><a href="/it/Firefox_OS/Platform/Gonk" title="it/Firefox_OS/Platform/Gonk">Gonk</a></dt>
 <dd>Gonk è il sistema operativo di basso livello della piattaforma Firefox OS, consiste di un Kernel Linux (derivato da quello sviluppato nel progetto <a href="http://source.android.com/">Android Open Source Project</a> (AOSP)) e di uno strato di astrazione dell&apos;hardware nello spazio di indirizzamento utente (<em>userspace HAL</em>). Il kernel e numerose librerie userspace sono noti progetti open source: Linux, libusb, bluez e via dicendo. Alcune parti del HAL sono condivise con il progetto AOSP: il GPS, la fotocamera, e altri. Si potrebbe dire che Gonk è una distribuzione di Linux. Gonk è uno dei sistemi su cui viene portato Gecko; cioè, così come c&apos;è un porting di Gecko per Gonk, c&apos;è un porting di Gecko per Mac OS, Windows e Android. Poichè il progetto Firefox OS ha il pieno controllo su Gonk, si possono esporre interfacce a Gecko che non possono essere esposte da altri sistemi operativi. Per esempio, Gecko ha accesso diretto allo stack di telefonia e al frame buffer di Gonk, ma non ha il medesimo accesso in ogni altro sistema operativo.</dd>
 <dt>Jank</dt>
 <dd><span lang="it"><span class="hps">Questo termine</span><span> normalmente </span><span class="hps">utilizzato </span><span class="hps">nel mondo delle</span> <span class="hps">app mobili</span><span>,</span> <span class="hps">si riferisce all&apos;effetto</span> <span class="hps">di</span> <span class="hps">lentezza piuttosto che di inefficienza indotto da codice non ottimizzato </span></span><span lang="it" id="result_box"><span>che </span></span>blocca<span lang="it"><span class="hps"><span lang="it" id="result_box"> <span class="hps">l&apos;aggiornamento</span> <span class="hps">dell&apos;interfaccia utente</span> <span class="hps">causando</span> <span class="hps">crash o</span> <span class="hps">ritardi nella risposta</span><span>.</span> <span class="hps">I nostri ingegneri</span> <span class="hps">lavorano su</span> <span class="hps">Gaia</span> <span class="hps">utilizzano varie</span> <span class="hps">tecniche </span><span class="hps">per cercare di</span> <span class="hps">evitare questo</span><span> effetto a tutti i costi.</span></span></span></span></dd>
</dl>

<h2 id="Architettura_d&apos;insieme">Architettura d&apos;insieme</h2>

<p>Nella seguente immagine viene confrontata l&apos;architettura di piattaforme proprietarie e quella di Firefox OS.</p>

<p><img src="https://mdn.mozillademos.org/files/9487/general-architecture.png" alt="on the left is a native mobile architecture stack, on the right is the Firefox OS architecture. they are similarm
except that the native stack is all proprietary device functionality, and the Firefox OS stack is all done with open source and we
b technologies." style="display: block; height: 488px; margin: 0px auto; width: 997px;"></p>

<p>Firefox OS ha eliminato lo strato di API native fra il sistema operativo e gli strati applicativi. Questa soluzione integrata riduce il carico della piattaforma e semplifica la gestione della sicurezza senza sacrificare le prestazioni e una ricca esperienza utente.</p>

<ol>
 <li><a href="/en-US/Firefox_OS/Platform/Gaia">Gaia</a> è l&apos;insieme delle web app principali e dell&apos;interfaccia utente di Firefox OS. È&apos; scritto in HTML5, CSS e JavaScript. Espone un insieme di API per consentire al codice della UI di interagire con l&apos;hardware del telefono e con le funzionalità di Gecko.</li>
 <li><a href="/en-US/docs/Mozilla/Gecko">Gecko</a> è il motore web e lo strato di presentazione di Firefox OS. Rappresenta l&apos;interfaccia fra i contenuti web e il dispositivo. Gecko fornisce il motore di parsing e rendering HTML5, un insieme di Web API sicure per accedere alle funzionalità hardware, un framework per la gestione della sicurezza, un sistema per la gestione degli aggiornamenti e altri servizi core.</li>
 <li><a href="/en-US/Firefox_OS/Platform/Gonk">Gonk</a> è il componente al livello del kernel nello stack di Firefox OS, è l&apos;interfaccia fra Gecko e l&apos;hardware del dispositivo. Gonk gestisce l&apos;hardware sottostante e espone le funzionalità dell&apos;hardware alle Web API implementate in Gecko. Gonk può essere visto come la “black box” che esegue il lavoro complesso e dettagliato dietro le scene, controllando il dispositivo mobile gestendo le richieste al livello hardware.</li>
 <li>Il dispositivo mobile è il telefono su cui viene eseguito Firefox OS. L&apos;OEM (Original Equipment Manifacturer, l&apos;azienda che ha costruito il dispositivo) è responsabile per la fornitura del dispositivo mobile.</li>
</ol>

<h2 id="Architettura_specifica_di_Firefox_OS">Architettura specifica di Firefox OS</h2>

<p><img src="/files/4605/FirefoxOS.png" alt="Firefox OS Architecture" style="display: block; height: 915px; margin: 0px auto; width: 754px;"></p>

<h2 id="Procedura_di_boot_di_Firefox_OS">Procedura di boot di Firefox OS</h2>

<p>Questa sezione descrive il processo di boot (avvio) dei dispositivi Firefox OS, quali componenti sono coinvolte e dove. Come introduzione, il flusso generale di boot del sistema va dal bootloader nello spazio di indirizzamente del kernel, a init nel codice nativo, a B2G e Gecko nello spazio utente e quindi finalmente alla system app, al window manager, alla homescreen app all&apos;interno di Gecko. <span lang="it" id="result_box"><span class="hps">Le altre</span> <span class="hps">applicazioni vengono eseguite</span> successivamente.</span></p>

<p><img src="https://mdn.mozillademos.org/files/7491/bootup.png" alt style="display: block; height: 1979px; margin: 0px auto; width: 2112px;"></p>

<h3 id="Il_processo_di_bootstrap">Il processo di bootstrap</h3>

<p>Quando un dispositivo Firefox OS viene avviato, l&apos;esecuzione inizia nel bootloader primario. Da li, il processo di caricamento del sistema operativo procede nella modalità tipica; una successione di bootloader di più alto livello caricano quello successivo. Alla fine d questo processo, l&apos;esecuzione viene passata al kernel Linux.</p>

<p>Ci sono alcuni punti che vale la pena menzionare nel processo di boot:</p>

<ul>
 <li>I bootloader generalmente visualizzano la prima immagina (<em>splash screen</em>) vista dall&apos;utente durante l&apos;avvio del dispositivo; tipicamente il logo del vendor.</li>
 <li>I bootloader implementano funzionalità per installare (<em>flashare</em>) nuove immagini sul dispositivo. Dispositivi differenti utilizzano protocolli differenti; la maggior parte dei telefoni utilizza il <a href="http://android-dls.com/wiki/index.php?title=Fastboot">protocollo fastboot</a>, il Samsung Galaxy S II invece utilizza il protocollo odin.</li>
 <li>Prima della conclusione del processo di boot, il firmware del modem viene caricato e portato in esecuzione sul processore del modem. La modalità con cui avviene è specifico per dispositivo e potrebbe anche essere codice proprietario.</li>
</ul>

<h3 id="Il_kernel_Linux">Il kernel Linux</h3>

<p>Il kernel Linux utilizzato da Gonk è veramente simile a quello originale da cui è derivato (basato sul progetto <a href="http://source.android.com/" title="http://source.android.com/">Android Open Source Project</a>). Ci sono piccole modifiche apportate nel progetto AOSP che non sono ancora stete depositate. Inoltre, i produttori di hardware alcune volte modificano il kernel e depositano tali modifiche sulla base della loro pianificazione. In generale, tuttavia, il kernel è simile all&apos;originale.</p>

<p>Il <a href="http://en.wikipedia.org/wiki/Linux_startup_process">processo di avvio di Linux</a> è ben documentato altrove in Internet, pertanto questo articolo non ne parlerà.</p>

<p>Il Kernel Linux gestirà le componenti hardware del dispositivo e i principali processi. Al termine della sequenza di avvio del Kernel verrà avviato init nello spazio di indirizzamento utente (userspace), come avviene nella maggior parte dei sistemi UNIX-like. Init eseguirà i processi definiti in <code>init.rc</code> e di seguito quelli definiti in <a href="https://github.com/mozilla-b2g/gonk-misc/blob/master/init.b2g.rc">init.b2g.rc</a> quali <code>b2g</code> (Il processo principale di Firefox OS, che contiene Gecko stesso) e <code>rild</code> (il processo che gestisce la componente hardware modem e radio del dispositivo) — vedi sotto per maggiori dettagli.</p>

<p>Dopo aver avviato <code>init</code>, il kernel gestisce le chiamate di sistema dai processi userspace e interrrupt dai dispositivi hardware. Molte funzionalità hardware vengono esposte ai processi userspace via <a href="http://en.wikipedia.org/wiki/Sysfs" title="http://en.wikipedia.org/wiki/Sysfs"><code>sysfs</code></a>. <span lang="it" class="long_text" id="result_box"><span class="hps">Ad esempio, il</span> <span class="hps">seguente è un </span> <span class="hps"><a href="https://github.com/cgjones/mozilla-central/blob/master/hal/gonk/GonkHal.cpp#L277" title="https://github.com/cgjones/mozilla-central/blob/master/hal/gonk/GonkHal.cpp#L277">estratto del codice</a> che legge</span> <span class="hps">lo stato di carica</span> <span class="hps">della batteria</span> in <span class="hps">Gecko</span><span>:</span></span></p>

<pre class="brush:cpp;">FILE *capacityFile = fopen(&quot;/sys/class/power_supply/battery/capacity&quot;, &quot;r&quot;);
double capacity = dom::battery::kDefaultLevel * 100;
if (capacityFile) {
  fscanf(capacityFile, &quot;%lf&quot;, &amp;capacity);
  fclose(capacityFile);
}</pre>

<h3 id="Altro_sul_processo_di_Init">Altro sul processo di Init</h3>

<p>Sempre <code>init</code> esegue il mount dei file system richiesti e l&apos;avvio dei servizi di sistema. Dopo di che, rimane attivo come gestore di processi. Similmente a come avviene in altri sistemi UNIX-like. Esso interpreta script (i file <code>init*.rc</code> ) che contengono i comandi per avviare vari servizi. Il file <code>init.rc</code> di Firefox OS è sostanzialmente quello orignale di Android per quel dispositivo modificato per includere quanto necessario ad avviare Firefox OS, e varia da dispositivo a dispositivo.</p>

<p>Un compito chiave gestito dal processo di <code>init</code> è l&apos;avvio del processo <code>b2g</code>; il core del sistema opetativo Firefox OS.</p>

<p>Il codice in <code>init.rc</code> per avviare <code>b2g </code>è simile al seguente:</p>

<pre>service b2g /system/bin/b2g.sh
  class main
  onrestart restart media</pre>

<div class="note notecard">
<p><strong>Nota:</strong> Esattamente quanto <code>init.rc</code> differisce dalla versione di Android varia da dispositivo a dispositivo; alcune volte <code>init.b2g.rc</code> è semplicemente aggiunto, altre volte le modifche sono più significative.</p>
</div>

<h2 id="L&apos;archituttura_dei_processi_userspace">L&apos;archituttura dei processi userspace</h2>

<p>Ora diamo uno sguardo di alto livello di come le varie componenti di Firefox OS interagiscono fra loro. Il diagramma mostra i principali processi userspace di Firefox OS.</p>

<p><a href="/files/3849/B2G userspace architecture.svg"><img src="/files/3849/B2G%20userspace%20architecture.svg" alt="Userspace diagram" style="float: right; height: 491px; position: relative; width: 520px;"></a></p>

<div class="note notecard">
<p><strong>Nota:</strong> Tieni a mente che Firefox OS è in sviluppo attivo, questo diagramma può cambiare e potrebbe non essere estremamente accurato.</p>
</div>

<p><code>b2g</code> è il processo primario di sistema. VIene eseguito con privilegi molto alti; ha accesso alla maggior parte dei device hardware. <code>b2g</code> comunica con il modem, scrive sul framebuffer dello schermo, interagisce col GPS, con le fotocamere e altre funzionalità hardware. <span lang="it" class="long_text" id="result_box"><span class="hps">Internamente</span> <span class="hps">B2G</span> <span class="hps">esegue lo strato di </span><span class="hps">Gecko</span> <span class="atn hps">(</span><span>implementato da</span> <span class="hps">libxul.so</span><span>)</span><span>.</span> Leggi l&apos;articolo su <a href="#Gecko">Gecko</a> per<span class="hps"> conoscere</span> <span class="hps">i dettagli di come</span> <span class="hps">funziona</span> <span class="hps">e come</span> <span class="hps">B2G</span> <span class="hps">comunica con</span> <span class="hps">lui</span><span>.</span></span></p>

<h3 id="b2g">b2g</h3>

<p>Il processo <code>b2g</code> avvia, di volta in volta, un numero di processi a bassa priorità chiamati <strong>content process</strong>. <span lang="it" class="long_text" id="result_box"><span class="hps">Si tratta di processi</span> <span class="hps">in cui vengono </span><span class="hps">caricate</span><span class="hps"> applicazioni</span> <span class="hps">web e</span> <span class="hps">altri contenuti</span> <span class="hps">web</span><span>.</span> <span lang="it" class="long_text" id="result_box"><span class="hps">Comunicano con</span> <span class="hps">Gecko </span><span class="hps">tramite</span> <a href="/en-US/docs/IPDL" title="/en-US/docs/IPDL">IPDL</a>, <span class="hps">un</span> <span class="hps">sistema</span> a passaggio di messaggi.</span></span></p>

<p>Il processo <code>b2g</code> esegue libxul, che referenzia <code>b2g/app/b2g.js</code> per le preferenze di default. Dalle preferenze viene letto il file HTML <code>b2g/chrome/content/shell.html</code>, compilato all&apos;interno del file <code>omni.ja</code>. <code>shell.html</code> include a sua volta il file <code>b2g/chrome/content/shell.js</code>, il quale avvia la <code>system</code> app di Gaia.</p>

<h3 id="rild">rild</h3>

<p>Il processo <code>rild</code> rappresenta l&apos;interfaccia fra i servizi di telefonia di Firefox OS e l&apos;hardware. <code>rild</code> è il <em>deamon</em> che implementa il <strong>Radio Interface Layer</strong> (RIL). In parte è codice proprietario ed è implementato dal produttore stesso dell&apos;hardware per comunicare con il modulo modem/radio. Codice cliente può interfacciarsi con <code>rild</code> tramite un socket UNIX-domain su cui <code>rild </code>è in ascolto. Viene avviato dallo script di <code>init</code>, verosimilmente come segue:</p>

<pre>service ril-daemon /system/bin/rild
  socket rild stream 660 root radio</pre>

<h3 id="rilproxy">rilproxy</h3>

<p>In Firefox OS il processo <code>rilproxy</code> è client di <code>rild</code> e agisce da proxy fra <code>rild</code> e <code>b2g</code>. È sufficente dire che tale proxy è richiesto come dettaglio di implementazione. <a href="https://github.com/mozilla-b2g/rilproxy">Potete trovate il codice di <code>rilproxy </code>su GitHub</a><code>.</code></p>

<h3 id="mediaserver">mediaserver</h3>

<p>Il <a href="https://github.com/android/platform_frameworks_base/tree/ics-mr0-release/media/libmediaplayerservice">processo <code>mediaserver</code></a> controlla la riproduzione di audio e video. Gecko si interfaccia ad esso tramite un meccanismo di chiamata di procedura remota di Android (<em>RPC, Remote Procedure Call</em>). Alcuni dei formati media che Gecko può riprodurre (OGG Vorbis audio, OGG Theora video, e <a href="http://www.webmproject.org/about/" title="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CDUQFjAA&amp;url=http%3A%2F%2Fwww.webmproject.org%2F&amp;ei=8Q84UOnoMoHH6wHZ44DwBA&amp;usg=AFQjCNHK9j6wyhUful5RmKCpU6b8GDfpYQ&amp;sig2=tCl8VxL3mCvrH86EyOwO_A">WebM</a> video) vengono decodificati da Gecko stesso e inviati direttamente al processo <code>mediaserver</code>. Altri formati vengono invece decodificati tramite <code>libstagefright</code>, che è in grado di accedere a codec proprietari e encoder hardware.</p>

<div class="note notecard">
<p><strong>Note:</strong> Il <code>mediaserver</code> è un componente &quot;temporaneo&quot; di Firefox OS. Si prevede che verrà sostituito ma non prima della versione 2.0 di Firefox OS.</p>
</div>

<h3 id="netd">netd</h3>

<p>Il processo <code>netd</code> viene utilizzato per configurare le interfacce di rete.</p>

<h3 id="wpa_supplicant">wpa_supplicant</h3>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">Il processo</span> <code>wpa_supplicant </code><span class="hps">è</span> <span class="hps">un servizio standard</span> <span class="hps">UNIX</span> <span class="hps">che gestisce</span> <span class="hps">la connettività con</span> access point WIFI.</span></p>

<h3 id="dbus-daemon">dbus-daemon</h3>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">Il processo</span> <span class="hps">dbus</span><span>-daemon</span> <span class="hps">implementa</span> <a href="http://www.freedesktop.org/wiki/Software/dbus"><span class="hps">D</span><span>-Bus</span></a>, un sistema di comunicazione fra processi basato su bus di sistema a scambio di messaggi. Viene<span class="hps"> </span><span class="hps">utilizzato</span> <span class="hps">da Firefox</span> <span class="hps">OS</span> <span class="hps">per la comunicazione</span> <span class="hps">Bluetooth</span><span>.</span></span></p>

<h2 id="Gecko">Gecko</h2>

<p><a href="/it/docs/Gecko" title="it/docs/Gecko">Gecko</a>, <span lang="it" class="long_text" id="result_box"><span class="hps">come già accennato</span><span>,</span> </span><span lang="it" class="long_text"><span class="hps">implementa gli</span> <span class="hps">standard web</span> <span class="atn hps">(</span><a href="/it/docs/Web/HTML"><span>HTML</span></a><span>,</span> <a href="/it/docs/CSS"><span class="hps">CSS</span></a><span>,</span> <span class="hps">e <a href="/it/docs/Web/JavaScript">JavaScript</a></span><span>) e viene utilizzato per implementare qualsiasi cosa l&apos;utente vede </span><span class="hps">in Firefox</span> <span class="hps">OS</span><span> e controlla tutte le interazioni con l&apos;hardware del telefono.</span></span> Le web app connettono l&apos;HTML5 all&apos;hardware attraverso l&apos;utilizzo controllato e sicuro di Web API, implementate in Gecko. Le Web API offrono accesso a funzionalità dello strato hardware del telefono (quali la batteria o la vibrazione) e ai dati memorizzati o disponibili sul telefono (quali il calendario o i contatti). I contenuti web richiamano le Web API all&apos;interno di HTML5.</p>

<p>Una app consiste in una collezione di contenuti web HTML5. Per costruire web app per dispositivi mobili Firefox OS gli sviluppatore semplicemente assemblano, pacchettizzano e distribuiscono questi contenuti web. A run time, i contenuti web vengono interpretati, compilati e renderizzati in un browser web. Per maggiori informazioni sulle App vai all&apos;<a href="https://developer.mozilla.org/en-US/Apps">App Center.</a></p>

<div class="note notecard">
<p><strong>Nota</strong>: <span lang="it" class="long_text" id="result_box"><span class="hps">Puoi trovare il codice sorgente di Gecko alla url </span><a href="http://dxr.mozilla.org">http://dxr.mozilla.org</a><span>. </span><span class="atn hps">E &apos;</span><span>un buon riferimento, ma </span><span>con un numero limitato di repository.</span> <span class="hps">Oppure puoi utilizzare il tradizionale </span> <a href="http://mxr.mozilla.org">http://mxr.mozilla.org</a><span>, </span><span class="hps">che contiene</span> <span class="hps">più progetti</span> <span class="hps">Mozilla</span><span>.</span></span></p>
</div>

<h3 id="Diagramma_architetturale_di_Gecko">Diagramma architetturale di Gecko</h3>

<p><img src="https://mdn.mozillademos.org/files/5027/securityframework.png" alt style="height: 591px; width: 979px;"></p>

<ul>
 <li><strong>Security Framework</strong>: contiene

  <ul>
   <li><strong>Permission Manager</strong>: Gateway di accesso alle funzionalità delle Web API.</li>
   <li><strong>Access Control List</strong>: Matrice di ruoli e permessi richiesti per accedere alle funzionalità delle Web API.</li>
   <li><strong>Credential Validation</strong>: Authenticazione per applicazioni/utenti.</li>
   <li><strong>Permissions Store</strong>: Insieme di privilegi richiesti per accedere alle funzionalità delle Web API.</li>
  </ul>
 </li>
 <li><strong>Web API</strong>: Insieme di API standard che espongono funzionalità hardware a contenuti web. Forniscono alle web app un&apos;accesso sicuro e programmatico a catteristiche del sottostante strato hardware del dispositivo mobile, assieme ai dati che sono memorizzati, o sono disponibili, sul dispositivo.</li>
 <li><strong>I/O</strong>: Interfaccia verso l&apos;hardware e archivi di dati.</li>
 <li><strong>Software Updates</strong>: Ottiene e installa aggiornamenti software di sistema e per le applicazioni di terze parti.</li>
 <li><strong>Content Layout &amp; Rendering</strong>: Il motore che analizza, interpreta ed esegue contenuti web e, con le informazioni di formattazione, mostra i contenuti formattati all&apos;utente.</li>
 <li><strong>b2g process</strong>: (Gecko) viene eseguito da un processo di sistema con privilegi elevati ed ha accesso all&apos;hardware del telefono. Le applicazioni in esecuzione sono processi figli di b2g.</li>
</ul>

<h3 id="I_file_di_Gecko_relativi_a_Firefox_OS">I file di Gecko relativi a Firefox OS</h3>

<h4 id="b2g_2">b2g/</h4>

<p>La cartella b2g contiene principalmente le funzioni relative a Firefox OS.</p>

<h5 id="b2gchromecontent">b2g/chrome/content</h5>

<p>Contiene i file Javascript che vengono eseguiti dalla system app.</p>

<h5 id="b2gchromecontentshell.html">b2g/chrome/content/shell.html</h5>

<p><span lang="it" class="long_text" id="result_box"><span class="atn hps">È </span><span>il punto di ingresso</span> <span class="hps">di Gaia</span> <span class="hps">-</span> <span class="hps">il codice HTML</span> <span class="hps">per</span> la<span class="hps"> system app. </span> <span class="hps"><code>shell.html</code></span> carica <span class="hps">settings.js</span> <span class="hps">e</span> <span class="hps">shell.js</span><span>:</span><span>.</span></span></p>

<pre class="brush: html">&lt;script type=&quot;application/javascript;version=1.8&quot; src=&quot;chrome://browser/content/settings.js&quot;&gt; &lt;/script&gt;
&lt;script type=&quot;application/javascript;version=1.8&quot; src=&quot;chrome://browser/content/shell.js&quot;&gt; &lt;/script&gt;</pre>

<p><code>settings.js</code> contiene i parametri di default di sistema.</p>

<h5 id="b2gchromecontentshell.js">b2g/chrome/content/shell.js</h5>

<p><code>shell.js</code> importa tutti i moduli necessari, registra i <em>listener </em>principali, imposta <code>sendCustomEvent</code> e <code>sendChromeEvent</code> per comunicare con Gaia e fornisce supporto per l&apos;installazione delle webapp: dalle quote di indexedDB, alle funzionalità di RemoteDebugger, al supporto per le tastiere e ai tool di cattura delle schermate.</p>

<p>La funzionalità più importante di <code>shell.js</code> è quella di avviare la <code>system </code>app di Gaia e successivamente quello di delegare tutte le attività di gestione alla <code>system</code> app stessa.</p>

<pre class="brush: js">let systemAppFrame =
  document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;html:iframe&apos;);
    ...
  container.appendChild(systemAppFrame);</pre>

<h5 id="b2gappb2g.js">b2g/app/b2g.js</h5>

<p>Questo script contiene le impostazioni predefinite, quali about:config nel browser e le stesse pref.js di Gaia. <span lang="it" class="long_text" id="result_box"><span class="hps">Queste impostazioni</span> <span class="hps">possono essere modificate</span> dalla app di Settings <span class="hps">o</span> <span class="hps">sovrascritte</span> <span class="hps">da</span> <span class="hps">user.js</span> <span class="hps">negli</span> <span class="hps">script di build</span> di Gaia.</span></p>

<h4 id="domAPI">dom/{API}</h4>

<p>Le nuove API (post-b2g) saranno collocate nella cartella <code>dom/</code>. Le vecchie API saranno collocate nella cartella dom/base, come ad esempio <code>Navigator.cpp</code>.</p>

<h5 id="domapps">dom/apps</h5>

<p><code>.jsm</code> verranno caricati— <code>.js</code> API quali <code>webapp.js</code> installate</p>

<h5 id="domappssrc">dom/apps/src/</h5>

<p>Tutti i permessi sono definiti in <a href="http://mxr.mozilla.org/mozilla-central/source/dom/apps/src/PermissionsTable.jsm">PermissionsTable.jsm</a></p>

<h4 id="domwebidl">dom/webidl</h4>

<p>WebIDL è il linguaggio utilizzato per definire le web API. Dai una lettura a <a href="https://developer.mozilla.org/en-US/docs/Mozilla/WebIDL_bindings">WebIDL_bindings</a> per conoscere quali attribuiti sono supportati.</p>

<h4 id="halgonk">hal/gonk</h4>

<p>Questa cartella contiene i file relativi ai livelli di porting di Gonk.</p>

<h4 id="File_generati">File generati</h4>

<h5 id="modulelibprefsrcinitall.js">module/libpref/src/init/all.js</h5>

<p>Contiene tutti i file di configurazione.</p>

<h5 id="systemb2g_omni.ja_and_omni.js">/system/b2g/ omni.ja and omni.js</h5>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">Contiene</span> i pacchetti di <span class="hps">stile</span>.</span></p>

<h3 id="Eleborazione_degli_eventi_di_input">Eleborazione degli eventi di input</h3>

<p>La maggior parte degli eventi di Gecko vengono innescati da azioni utente, quali la pressione di pulsanti, il tocco su un touch screen, e così via. Questi eventi vengono acquisiti da Gecko tramite l&apos;interfaccia <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIAppShell">nsIAppShell</a> <a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsAppShell.cpp">implementata da Gonk</a> che rappresenta il punto di ingresso principale per una applicazione di Gecko; cioè, il device driver della periferica di input richiamerà i metodi esposti dall&apos;oggetto <code>nsAppShell</code> che rappresenta il sottosistema di Gecko per inviare eventi all&apos;interfaccia utente.</p>

<p>Per esempio:</p>

<pre class="brush:cpp;">void GeckoInputDispatcher::notifyKey(nsecs_t eventTime,
                                     int32_t deviceId,
                                     int32_t source,
                                     uint32_t policyFlags,
                                     int32_t action,
                                     int32_t flags,
                                     int32_t keyCode,
                                     int32_t scanCode,
                                     int32_t metaState,
                                     nsecs_t downTime) {
  UserInputData data;
  data.timeMs = nanosecsToMillisecs(eventTime);
  data.type = UserInputData::KEY_DATA;
  data.action = action;
  data.flags = flags;
  data.metaState = metaState;
  data.key.keyCode = keyCode;
  data.key.scanCode = scanCode;
  {
    MutexAutoLock lock(mQueueLock);
    mEventQueue.push(data);
  }
  gAppShell-&gt;NotifyNativeEvent();
}</pre>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">Questi eventi</span> <span class="hps">provengono dal sistema</span> <span class="hps">input_event</span> <span class="hps">standard di Linux</span><span>.</span> <span class="hps">Su questa struttura Firefox</span> <span class="hps">OS</span> <span class="hps">ha implementato uno </span> <a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/libui/InputReader.cpp"><span class="atn hps">s</span><span>trato</span> <span class="hps">di astrazione</span></a><span class="hps"> </span><span class="hps">che</span> <span class="hps">fornisce alcune</span> <span class="hps">funzioni molto utili come</span> <span class="hps">il filtro degli eventi</span><span>.</span> <span class="hps">Si può vedere</span> <span class="hps">il codice che crea</span> <span class="hps">eventi di input nel metodo </span> <span class="hps">EventHub</span> <span class="hps">::</span> <span class="hps">GetEvents</span> <span class="hps">in</span> <a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/libui/EventHub.cpp"><span class="hps">widget/</span><span class="hps">Gonk</span><span class="hps">/</span><span class="hps">libui</span>/E<span class="hps">ventHub.cpp</span></a><span>.</span></span></p>

<p>Una volta ricevuti da Gecko, gli eventi vengono inoltrati al DOM da <code><a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsAppShell.cpp">nsAppShell</a>:</code></p>

<pre class="brush:cpp;">static nsEventStatus sendKeyEventWithMsg(uint32_t keyCode,
                                         uint32_t msg,
                                         uint64_t timeMs,
                                         uint32_t flags) {
    nsKeyEvent event(true, msg, NULL);
    event.keyCode = keyCode;
    event.location = nsIDOMKeyEvent::DOM_KEY_LOCATION_MOBILE;
    event.time = timeMs;
    event.flags |= flags;
    return nsWindow::DispatchInputEvent(event);
}
</pre>

<p>Dopo di che, gli eventi vengono consumati da Gecko stesso o vengono inoltrati alle applicazioni Web come <a href="/en-US/docs/DOM_Client_Object_Cross-Reference/DOM_Events" title="/en-US/docs/DOM_Client_Object_Cross-Reference/DOM_Events">eventi DOM</a> per ulteriori elaborazioni.</p>

<h3 id="Grafica">Grafica</h3>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">Al livello</span> <span class="hps">più basso</span><span>,</span> <span class="hps">Gecko</span> <span class="hps">utilizza <a href="http://www.khronos.org/opengles/2_X/">OpenGL ES 2.0 </a></span> <span class="hps">per disegnare un contesto OpenGL. </span><span class="hps">Questo avviene in </span><a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsWindow.cpp"><span>NSWindow</span></a><span><a href="http://mxr.mozilla.org/mozilla-central/source/widget/gonk/nsWindow.cpp"> </a>implementata da Gonk, con c</span><span class="hps">odice</span> <span class="hps">simile a questo</span><span>:</span></span></p>

<pre class="brush:cpp;">gNativeWindow = new android::FramebufferNativeWindow();
sGLContext = GLContextProvider::CreateForWindow(this);</pre>

<p>La classe <code>FramebufferNativeWindow</code> è quella nativa Android; vedi <a href="https://github.com/android/platform_frameworks_base/blob/ics-mr1-release/libs/ui/FramebufferNativeWindow.cpp" title="https://github.com/android/platform_frameworks_base/blob/ics-mr1-release/libs/ui/FramebufferNativeWindow.cpp"><code>FramebufferNativeWindow.cpp</code></a>. Essa utilizza le API <strong>gralloc</strong> per accedere ai driver grafici per mappare i buffer dal framebuffer nella memoria.</p>

<p>Gecko usa i suoi <a href="/en-US/docs/Gecko/Layers" title="/en-US/docs/Gecko/Layers">Layers</a> per comporre contesti sullo schermo. In sintesi accade quanto di seguito descritto:</p>

<ol>
 <li>Gecko scrive regioni di pagine separate in buffer di memoria. Spesso questi buffer sono nella memoria di sistema; altre volte sono delle texture mappate nello spazio di indirizzamento di Gecko, il che significha che Gecko sta scrivendo direttamente nela memoria video. Questo avviene generalmente attraverso il metodo <a href="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#83" title="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#201"><code>BasicThebesLayer::PaintThebes()</code></a>.</li>
 <li>Gecko quindi compone tutte le texture sullo schermo utilizzando comandi OpenGL. Questa composizione avviene in <a href="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/opengl/ThebesLayerOGL.cpp#124" title="http://mxr.mozilla.org/mozilla-central/source/gfx/layers/basic/BasicThebesLayer.cpp#201"><code>ThebesLayerOGL::RenderTo()</code></a>.</li>
</ol>

<p><span lang="it" class="long_text" id="result_box"><span class="hps">I dettagli</span> <span class="hps">di come il</span> <span class="hps">Gecko</span> <span class="hps">gestisce il rendering</span> <span class="hps">dei contenuti</span> <span class="hps">web è</span> <span class="hps">oltre lo scopo di</span> <span class="hps">questo documento</span><span>.</span></span></p>

<h3 id="Hardware_Abstraction_Layer_(HAL)">Hardware Abstraction Layer (HAL)</h3>

<p>Lo strato di astrazione dell&apos;hardware di Gecko è uno dei livelli di portabilità. Gestisce l&apos;accesso alle interfacce di sistema di più basso livello su più piattaforme attraverso API C++, utilizzate dai livelli più alti di Gecko. Queste API sono implementate su base piattaforma all&apos;interno del HAL di Gecko stesso. Lo strato di astrazione dell&apos;hardware non viene esposto direttamente al codice JavaScript in Gecko - di questa interazione se ne occupano le Web API.</p>

<p>Diamo uno sguardo al processo da una prospettiva di più alto livello. Quando un utente utilizza una funzionalità del telefono (ad esempio effettua una chiamata, accede ad una rete wifi o si connette via Bluetooth), tutti gli strati dello stack tecnologico di Firefox OS vengono coinvolti per completare la richiesta. Le applicazioni e i contenuti web sottopongono le richieste per accedere al dispositivo attraverso chiamate alle Web API (direttamente all&apos;interno di funzioni HTML5) implementate in Gecko. Gecko, a sua volta, sottopone le richieste a Gonk. Una singola richiesta di Gecko può innescare una serie complessa di operazioni, avviate e gestite da Gonk, sul dispositivo mobile.</p>

<h4 id="Come_lavora_HAL">Come lavora HAL</h4>

<p>Consideriamo come esempio la API di <a href="/en-US/docs/Web/API/window.navigator.vibrate">Vibrazione</a>. Definita in <a href="http://mxr.mozilla.org/mozilla-central/source/hal/Hal.h">hal/Hal.h</a>. In sintesi (semplificando la firma del metodo), abbiamo la seguente funzione:</p>

<pre>void Vibrate(const nsTArray&lt;uint32&gt; &amp;pattern);</pre>

<p>Questa è la funzione chiamata dal codice di Gecko per abilitare la vibrazione del dispositivo in accordo con lo specifico <em>pattern</em>; una funzione corrispondente è disponibile per rimuovere la vibrazione. L&apos;implementazione di Gonk di questo metodo è presente nel file <a href="http://mxr.mozilla.org/mozilla-central/source/hal/conk/GonkHal.cpp">hal/gonk/GonkHal.cpp</a>:</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt; &amp;pattern) {
  EnsureVibratorThreadInitialized();
  sVibratorRunnable-&gt;Vibrate(pattern);
}
</pre>

<p>Viene inviata la richiesta per avviare la vibrazione sul dispositivo ad un altro thread, tramite l&apos;istruzione <code>VibratorRunnable::Run()</code>. Il ciclo principale di questo thread è simile al seguente:</p>

<pre class="brush:cpp;">while (!mShuttingDown) {
  if (mIndex &lt; mPattern.Length()) {
    uint32_t duration = mPattern[mIndex];
    if (mIndex % 2 == 0) {
      vibrator_on(duration);
    }
    mIndex++;
    mMonitor.Wait(PR_MillisecondsToInterval(duration));
  }
  else {
    mMonitor.Wait();
  }
}
</pre>

<p><code>vibrator_on()</code> è la API definita nel HAL di Gonk che avvia il motore di vibrazione. Internamente questo metodo invia un messaggio all&apos;apposito driver scrivendo su un oggetto del kernel attraverso <code>sysfs</code>.</p>

<h4 id="Implementazione_delle_API_di_Fallback_del_HAL">Implementazione delle API di Fallback del HAL</h4>

<p>Le API HAL di Gecko sono sempre disponibili su tutte le piattaforme. Se Gecko viene portato su una nuova piattaforma che non espone il motore di vibrazione (ad esempio un desktop), viene comunque resa disponibile una API di <em>fallback</em>. Per il motore di vibrazione la API è implementata in <a href="http://mxr.mozilla.org/mozilla-central/source/hal/fallback/FallbackVibration.cpp">hal/fallback/FallbackVibration.cpp</a>.</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt; &amp;pattern) {
}</pre>

<h4 id="Implementazione_delle_Sandbox">Implementazione delle Sandbox</h4>

<p>Poichè molti contenuti web vengono eseguiti in <em>content process</em> con privilegi bassi, non possiamo assumere che quei processi abbiano i privilegi adeguati (ad esempio) per avviare o spegnere il motore di vibrazione. Inoltre, vorremmo avere un posto unico in cui gestire eventuali situazioni di <em>race condition</em>. Nel HAL di Gecko questo viene gestito tramite una &quot;sandbox&quot;. La sandbox agisce come un proxy, semplicemente inoltrando le richieste dei content process al &quot;Gecko server&quot;. Le richieste vengono inoltrate utilizzando IPDL.</p>

<p>Per la vibrazione, questo viene gestito dalla funzione di <code>Vibrate()</code> implementata in <a href="http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp">hal/sandbox/SandboxHal.cpp</a>:</p>

<pre class="brush:cpp;">void Vibrate(const nsTArray&lt;uint32_t&gt;&amp; pattern, const WindowIdentifier &amp;id) {
  AutoInfallibleTArray&lt;uint32_t, 8&gt; p(pattern);

  WindowIdentifier newID(id);
  newID.AppendProcessID();
  Hal()-&gt;SendVibrate(p, newID.AsArray(), GetTabChildFrom(newID.GetWindow()));
}</pre>

<p>Viene inviato un messaggio definito nell&apos;interfaccia <code>PHal</code>, definita in <a href="http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/PHal.ipdl">hal/sandbox/PHal.ipdl</a>. Questo metodo è descritto più o meno come segue:</p>

<pre>Vibrate(uint32_t[] pattern);</pre>

<p>Il messaggio viene ricevuto dal metodo <code>HalParent::RecvVibrate()</code> implementato in <a href="http://mxr.mozilla.org/mozilla-central/source/hal/sandbox/SandboxHal.cpp">hal/sandbox/SandboxHal.cpp</a>, come segue:</p>

<pre class="brush:cpp;">virtual bool RecvVibrate(const InfallibleTArray&lt;unsigned int&gt;&amp; pattern,
            const InfallibleTArray&lt;uint64_t&gt; &amp;id,
            PBrowserParent *browserParent) MOZ_OVERRIDE {

  hal::Vibrate(pattern, newID);
  return true;
}</pre>

<p>Sono stati omessi alcuni dettagli non rilevanti alla discussione; comunque, è stato mostrato come i messaggi progrediscono da un content process in Gecko a Gonk, quindi all&apos;implementazione di <code>Vibrate()</code> nella HAL di Gonk e infine al driver che gestisce il motore di vibrazionie.</p>

<h3 id="Le_API_DOM">Le API DOM</h3>

<p><strong>Le interfacce DOM </strong> rappresentano la modalità con cui i web content comunicano con Gecko. In realtà c&apos;è molto più e se sei interessato, puoi leggere l&apos;articolo <a href="/en-US/docs/DOM/About_the_Document_Object_Model" title="/en-US/docs/DOM/About_the_Document_Object_Model">about the DOM</a>. Le interfacce DOM vengono definite utilizzando <a href="/en-US/docs/XPIDL" title="/en-US/docs/XPIDL">IDL</a>, che comprende sia una funzione esterna (<em>foreign function interface</em>, FFI) che un modello di oggetto (<em>object model</em>, OM) fra Javascript e C++.</p>

<p>La API di Vibrazione viene esposta attraverso un&apos;interfaccia IDL <code><a href="http://mxr.mozilla.org/mozilla-central/source/dom/interfaces/base/nsIDOMNavigator.idl">nsIDOMNavigator.idl</a>:</code></p>

<pre>[implicit_jscontext] void mozVibrate(in jsval aPattern);</pre>

<p>L&apos;argomento <a href="/en-US/docs/SpiderMonkey/JSAPI_Reference/Jsval" title="/en-US/docs/SpiderMonkey/JSAPI_Reference/JSVAL_IS_OBJECT"><code>jsval</code></a> indica che <code>mozVibrate()</code> accetta come parametro di input qualsiasi valore. Il compilatore IDL, <a href="/en-US/docs/XPIDL/xpidl" title="/en-US/docs/XPIDL/xpidl"><code>xpidl</code></a>, genera l&apos;interfaccia C++ che viene viene quindi implementata dalla classe <code>Navigator</code> in <code><a href="http://mxr.mozilla.org/mozilla-central/source/dom/base/Navigator.cpp">Navigator.cpp</a>.</code></p>

<pre class="brush:cpp;">NS_IMETHODIMP Navigator::MozVibrate(const jsval&amp; aPattern, JSContext* cx) {
  // ...
  hal::Vibrate(pattern);
  return NS_OK;
}</pre>

<p>C&apos;è molto più codice in questo metodo di quanto riportato, ma non è importante ai fini della discussione. Il punto è che la chiamata a <code>hal::Vibrate()</code> trasferisce il controllo dal DOM all&apos;HAL di Gecko. Da qui, entriamo nell&apos;implementazione del HAL discusso precedentemente fino al driver della scheda di rete. Soprattutto, l&apos;implementazione del DOM è indipendente dalla piattaforma su cui è in esecuzione (Gonk, Windows, Mac OS X o qualsiasi altra). Inoltre non si preoccupa se il codice viene eseguito in un content process o nel server Gecko. Questo dettagli sono lasciati ai layer di sistema che se ne occupa.</p>

<p>L&apos;API di Vibrazione è molto semplice e ciò la rende un buon esempio. L&apos; <a href="/en-US/docs/API/WebSMS" title="/en-US/docs/API/WebSMS">API di SMS </a>è un esempio di API più complessa che utilizza un proprio strato &quot;remoto&quot; per connettere il content process al server.</p>

<h2 id="Radio_Interface_Layer_(RIL)">Radio Interface Layer (RIL)</h2>

<p>Il RIL è stato menzionato nella sezione <a href="#L&apos;archituttura_dei_processi_userspace">L&apos;archituttura dei processi userspace</a>. Questa sezione esaminerà come le varie componenti di questo strato interagiscono in maggior dettaglio.</p>

<p>Le principali componenti sono:</p>

<dl>
 <dt><code>rild</code></dt>
 <dd>Il daemon che interagisce con il firmware proprietario del modem.</dd>
 <dt><code>rilproxy</code></dt>
 <dd>il daemon che agisce come proxy fra <code>rild</code> e Gecko (implementato nel processo <code>b2g</code>). <span lang="it" class="long_text" id="result_box"><span class="hps">Questo risolve</span> <span class="hps">il</span> <span class="hps">problema di autorizzazione</span> <span class="hps">che si pone</span> <span class="hps">quando si cerca</span> <span class="hps">di interagire direttamente con</span> <span class="hps">rild</span><span>,</span> in quanto è possibile farlo <span class="hps">solo per chi appartiene al gruppo </span><span class="hps">radio.</span></span></dd>
 <dt><code>b2g</code></dt>
 <dd>Questo processo, conoscuto anche col nome di <strong>chrome</strong>, implementa Gecko. Le componenti di b2g che interagiscono con RIL sono un <em>worker thread</em> implementato in <a href="http://mxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_worker.js">dom/system/gonk/ril_worker.js</a> che interagisce con <code>rild</code> attraverso <code>rilproxy</code> e implementa la macchina a stati del modem; e l&apos;interfaccia <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer">nsIRadioInterfaceLayer</a> che è il thread primario del servizio <a href="/en-US/docs/XPCOM" title="/en-US/docs/XPCOM">XPCOM</a> e agisce principalmente per scambiare messaggi fra il worker thread <code>ril_worker.js</code> e le varie componenti di Gecko, inclusi i content process.</dd>
 <dt>I content process di Gecko</dt>
 <dd>All&apos;interno dei content process di Gecko l&apos;interfaccia <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRILContentHelper">nsIRILContentHelper </a>fornisce un servizio XPCOM che permette al codice che implementa parti del DOM, quali le API <a href="/en-US/docs/API/WebTelephony" title="/en-US/docs/API/WebTelephony">Telephony</a> e <a href="/en-US/docs/API/WebSMS" title="/en-US/docs/API/WebSMS">SMS</a>, di comunicare con l&apos;interfaccia modem/radio, che risiede nel processo chrome.</dd>
</dl>

<h3 id="Esempio_Communicazione_da_rild_al_DOM">Esempio: Communicazione da rild al DOM</h3>

<p>Diamo un&apos;occhiata ad un esempio di come le parti basse del sistema comunicano col DOM. Quando il modem riceve una chiamata in ingresso, avvisa <code>rild</code> utilizzando un meccanismo proprietario. <code>rild</code> quindi prepara un messaggio per il suo client in conformità con un protocollo &quot;open&quot; descritto in <a href="https://github.com/mozilla-b2g/android-hardware-ril/blob/master/include/telephony/ril.h" title="https://github.com/mozilla-b2g/android-hardware-ril/blob/master/include/telephony/ril.h"><code>ril.h</code></a>. Sempre nel caso di una chiamata in ingresso, un messaggio <code>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</code> viene generato e inviato da <code>rild</code> a <code>rilproxy</code>.</p>

<p><code>rilproxy</code>, implementato in <a href="https://github.com/mozilla-b2g/rilproxy/blob/master/src/rilproxy.c" title="https://github.com/mozilla-b2g/rilproxy/blob/master/src/rilproxy.c"><code>rilproxy.c</code></a>, riceve questo messaggio nel suo ciclo principale mettendosi in <em>polling </em>sulla connessione con <code>rild</code> nel seguente modo:</p>

<pre class="brush:cpp;">ret = read(rilproxy_rw, data, 1024);

if(ret &gt; 0) {
  writeToSocket(rild_rw, data, ret);
}</pre>

<p>Dopo aver ricevuto il messaggio da <code>rild</code>, <code>rilproxy </code>lo invia a Gecko attraverso la socket che li connette. Gecko riceve il messaggio tramite l&apos;<a href="https://dxr.mozilla.org/mozilla-central/source/ipc/ril/Ril.cpp" rel="custom">IPC thread</a>:</p>

<pre class="brush:cpp;">int ret = read(fd, mIncoming-&gt;Data, 1024);
// ... handle errors ...
mIncoming-&gt;mSize = ret;
sConsumer-&gt;MessageReceived(mIncoming.forget());
</pre>

<p>Il consumatore di questi messaggi è il <a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/SystemWorkerManager.cpp" rel="custom">SystemWorkerManager</a>, che riconfeziona il messaggio e lo inoltra al worker thread <code><a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_worker.js" rel="custom">ril_worker.js</a></code> che implementa la macchina a stati di RIL; questo avviene nel metodo <code>RILReceiver::MessageReceived()</code>:</p>

<pre class="brush:cpp;">virtual void MessageReceived(RilRawData *aMessage) {
  nsRefPtr&lt;DispatchRILEvent&gt; dre(new DispatchRILEvent(aMessage));
  mDispatcher-&gt;PostTask(dre);
}</pre>

<p>PostTask a sua volta chiama la funzione <code>onRILMessage(),</code>implementata in Javascript. Ciò avviene utilizzando la API JavaScript <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_CallFunctionName" title="/en-US/docs/SpiderMonkey/JSAPI_Reference/JS_CallFunctionName">JS_CallFunctionName</a><code>()</code>:</p>

<pre>return JS_CallFunctionName(aCx, obj, &quot;onRILMessage&quot;, NS_ARRAY_LENGTH(argv),
                           argv, argv);</pre>

<p><code>onRILMessage()</code> è implementata in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/system/gonk/ril_woker.js" rel="custom">dom/system/gonk/ril_woker.js</a>, elabora il messaggio e lo scompone. Ciascun pacchetto viene quindi inviato ad un gestore appropriato:</p>

<pre class="brush:js;">handleParcel: function handleParcel(request_type, length) {
  let method = this[request_type];
  if (typeof method == &quot;function&quot;) {
    if (DEBUG) debug(&quot;Handling parcel as &quot; + method.name);
    method.call(this, length);
  }
}
</pre>

<p>Il gestore verifica la tipologia di richiesta assicurandosi che sia definita come funzione nel codice JavaScript, e solo successivamente chiamando il metodo. ril_worker.js implementa un metodo specifico per ciascun tipo di richiesta.</p>

<p>Nel nostro esempio in corrispondenza a <code>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</code> viene chiamato il seguente gestore:</p>

<pre class="brush:js;">RIL[UNSOLICITED_RESPONSE_CALL_STATE_CHANGED] = function UNSOLICITED_RESPONSE_CALL_STATE_CHANGED() {
  this.getCurrentCalls();
};</pre>

<p>Come puoi notare dal codice, se lo stato è cambiato durante la ricezione della notifica viene aggiornato semplicemente chiamando il metodo getCurrentCall():</p>

<pre class="brush:js;">getCurrentCalls: function getCurrentCalls() {
  Buf.simpleRequest(REQUEST_GET_CURRENT_CALLS);
}</pre>

<p>il quale invia una richiesta a rild per acquisire lo stato di tutte le chiamate attive. La richiesta segue il medesimo percorso ma inverso rispetto a quello seguito da RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED (cioè da ril_worker.js a SystemWorkerManager a Ril.cpp, quindi a rilproxy e finalmente a rild). rild quindi risponde, seguendo il medesimo percorso, fino al gestore dell&apos;evento del messaggio REQUEST_GET_CURRENT_CALLS all&apos;interno di ril_worker.js. In questo modo avvengono le comunicazioni bidirezionali.</p>

<p>Lo stato viene quindi comparato con lo stato precedente; se c&apos;è stato un cambio, ril_worker.js aggiorna il servizio <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer">nsIRadioInterfaceLayer</a>:</p>

<pre class="brush:js;">_handleChangedCallState: function _handleChangedCallState(changedCall) {
  let message = {type: &quot;callStateChange&quot;,
                 call: changedCall};
  this.sendDOMMessage(message);
}</pre>

<p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRadioInterfaceLayer">nsIRadioInterfaceLayer </a>è implementato in <a href="https://dxr.mozilla.org/mozilla-central/source/dom/syste/gonk/RadioInterfaceLayer.js" rel="custom">dom/syste/gonk/RadioInterfaceLayer.js</a>; il messaggio viene ricevuto dal suo metodo onmessage():</p>

<pre class="brush:js;"> onmessage: function onmessage(event) {
   let message = event.data;
   debug(&quot;Received message from worker: &quot; + JSON.stringify(message));
   switch (message.type) {
     case &quot;callStateChange&quot;:
       // This one will handle its own notifications.
       this.handleCallStateChange(message.call);
       break;
   ...
</pre>

<p>e successivamente inviato al content process tramite il Parent Process Message Manager (PPMM):</p>

<pre class="brush:js;">handleCallStateChange: function handleCallStateChange(call) {
  [some internal state updating]
  ppmm.sendAsyncMessage(&quot;RIL:CallStateChanged&quot;, call);
}</pre>

<p>Nel content process, il messaggio viene ricevuto dal metodo <code>receiveMessage() </code>definito nel servizio <code><a href="/it/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRILContentHelper" title>nsIRILContentHelper</a></code>, dal Child Process Message Manager (CPMM):</p>

<pre class="brush:js;">receiveMessage: function receiveMessage(msg) {
  let request;
  debug(&quot;Received message &apos;&quot; + msg.name + &quot;&apos;: &quot; + JSON.stringify(msg.json));
  switch (msg.name) {
    case &quot;RIL:CallStateChanged&quot;:
      this._deliverTelephonyCallback(&quot;callStateChanged&quot;,
                                     [msg.json.callIndex, msg.json.state,
                                     msg.json.number, msg.json.isActive]);
      break;</pre>

<p>Questo, a sua volta, invoca <code><a href="https://developer.mozilla.org/it/docs/XPCOM_Interface_Reference/nsIRILTelephonyCallback#callStateChanged()">nsIRILTelephonyCallback.callStateChanged()</a></code> per ciascun oggetto che ha registrato un metodo di callback. Ogni applicazione web che accede alla API <a href="https://developer.mozilla.org/en-US/docs/Web/API/window.navigator.mozTelephony">window.navigator.mozTelephony</a> registra un proprio metodo di callback che inoltrerà gli eventi al codice JavaScript all&apos;interno dell&apos;applicatione web, sia come evento di cambio stato che di un evento di chiamata in <code>ingresso.</code></p>

<pre class="brush:cpp;">NS_IMETHODIMP Telephony::CallStateChanged(PRUint32 aCallIndex, PRUint16 aCallState,
                                          const nsAString&amp; aNumber, bool aIsActive) {
  [...]

  if (modifiedCall) {
    // Change state.
    modifiedCall-&gt;ChangeState(aCallState);

    // See if this should replace our current active call.
    if (aIsActive) {
      mActiveCall = modifiedCall;
    }

    return NS_OK;
  }

  nsRefPtr&lt;TelephonyCall&gt; call =
          TelephonyCall::Create(this, aNumber, aCallState, aCallIndex);
  nsRefPtr&lt;CallEvent&gt; event = CallEvent::Create(call);
  nsresult rv = event-&gt;Dispatch(ToIDOMEventTarget(), NS_LITERAL_STRING(&quot;incoming&quot;));
  NS_ENSURE_SUCCESS(rv, rv);
  return NS_OK;
}</pre>

<p>Le appicazioni possono ricevere tali eventi e aggiornare di conseguenza la propria interfaccia utente:</p>

<pre class="brush:js;">handleEvent: function fm_handleEvent(evt) {
  switch (evt.call.state) {
    case &apos;connected&apos;:
      this.connected();
      break;
    case &apos;disconnected&apos;:
      this.disconnected();
      break;
    default:
      break;
  }
}</pre>

<p>Dai uno sguardo all&apos;implementazione di <a href="https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/dialer/js/dialer.js" title="https://github.com/mozilla-b2g/gaia/blob/master/apps/communications/dialer/js/dialer.js"><code>handleEvent()</code> nell&apos;applicazione Dialer</a> come ulteriore esempio.</p>

<h3 id="3G_dati">3G dati</h3>

<p>Una &quot;chiamata dati&quot; viene inizializzata tramite un messaggio RIL; questo abilita la modalità di trasferimento dati al modem. Tale chiamata crea e attiva un&apos;interfaccia <a href="https://it.wikipedia.org/wiki/Point-to-Point Protocol" title="Point-to-Point Protocol">Point-to-Point Protocol</a> (PPP) nel kernel linux che potrà essere configurata utilizzando le interfacce usuali.</p>

<div class="note notecard">
<p><strong>Nota:</strong> Questa sessione necessita di essere scritta.</p>
</div>

<h3 id="API_DOM_relative">API DOM relative</h3>

<p>Segue la lista delle API DOM relative alla comunicazione con RIL:</p>

<ul>
 <li><a href="/en-US/docs/API/WebTelephony/Introduction_to_WebTelephony">Telephony API</a></li>
 <li><a href="/en-US/docs/API/WebSMS/Introduction_to_WebSMS">SMS API</a></li>
 <li>Mobile Connection API</li>
</ul>

<h2 id="Wi-Fi">Wi-Fi</h2>

<p>La maggior parte del lavoro di back end per Firefox OS viene effettuato dal processo <code>wpa_supplicant</code>. Ciò significa che l&apos;attività principale del back end è quella di gestire il supplicant e di svolgere alcuni compiti ausiliari quali caricare il driver del WIFI e abilitare o disabilitare le interfacce di rete. In pratica, questo significa che il back end è la macchina a stati, con un&apos;evoluzione degli stati che segue quella del supplicant.</p>

<div class="note notecard">
<p><strong>Nota:</strong> Molto di ciò che accade nel WIFI dipende dai cambiamenti di stato nel processo <code>wpa_supplicant</code>.</p>
</div>

<p>L&apos;implementazione delle componenti che costituiscono il WiFi è suddivisa in due file:</p>

<dl>
 <dt><a href="https://dxr.mozilla.org/mozilla-central/source/dom/wifi/DOMWifiManager.js" rel="custom">dom/wifi/DOMWifiManager.js</a></dt>
 <dd>Implementa le API esposte ai web content, come definite in <code><a href="/it/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIWifi.idl" title>nsIWifi.idl</a></code>.</dd>
 <dt><a href="https://dxr.mozilla.org/mozilla-central/source/dom/wifi/WifiWorker.js" rel="custom">dom/wifi/WifiWorker.js</a></dt>
 <dd>Implementa la macchina a stati e il codice che gestisce il supplicant.</dd>
</dl>

<p>Questi due file comunicano tra loro utilizzando il <a href="/en-US/docs/The_message_manager" title="/en-US/docs/The_message_manager">message manager</a>. Il back end rimane in ascolto di messaggi che richiedono certi azioni, quali l&apos;&quot;associazione&quot; e risponde con un messaggio quando l&apos;azione richiesta è stata espletata.</p>

<p>La parte del DOM si pone in ascolto sia sulle risposte che di eventuali eventi che notificano cambiamenti di stato o l&apos;aggiornamento di informazioni.</p>

<div class="note notecard">
<p><strong>Nota:</strong> Ogni API sincrona del DOM viene implementata tenendo in cache i dati nella sua parte dell&apos;interfaccia. Messaggi sincroni vanno evitati ogni qualvolta sia possibile.</p>
</div>

<h3 id="WifiWorker.js">WifiWorker.js</h3>

<p>Questo file implementa la logica principale dell&apos;interfaccia WIFI. Viene eseguito nel processo chrome e istanziato dal SystemWorkerManager. È suddiviso in due sezioni: una funzione anonima e il <code>WifiWorker</code>. La funzione anonima finisce per essere il <code>WifiManager</code> fornendo una API locale, comprese le notifiche per eventi quali le connessioni al supplicant e i risultati. <span lang="it" id="result_box"><span class="hps">In</span> <span class="hps">generale</span><span>, contiene</span> <span class="hps">poca</span> <span class="hps">logica,</span> <span class="hps">risponde</span> <span class="hps">semplicemente</span> <span class="hps">con</span> <span class="hps">le informazioni richieste e</span> <span class="hps">controlla</span> <span class="hps">i</span> <span class="hps">dettagli della connessione</span> <span class="hps">con</span> <span class="hps">il richiedente</span><span>.</span></span></p>

<p>Il <code>WifiWorker</code> si colloca fra il <code>WifiManager</code> e il DOM. Risponde agli eventi e li inoltra al DOM, riceve richieste dal DOM ed esegue le appropriate azioni sul supplicant. Inoltre mantiene le informazioni di stato del supplicant e queli azioni intraprendere di conseguenza.</p>

<h3 id="DOMWifiManager.js">DOMWifiManager.js</h3>

<p>Implementa la API del DOM, gestisce le richieste da e verso i chiamanti e il WiFi worker. C&apos;è veramente poca logica.</p>

<div class="note notecard">
<p><strong>Nota:</strong> Per evitare messaggi sincroni nel processo chrome il WIFI manager tenendo in cache lo stato in funzione dell&apos;evento ricevuto.</p>
</div>

<p>C&apos;è un unico messaggio sincrono, inviato nel momento in cui la API del DOM viene istanziata per ottenere lo stato del supplicant.</p>

<h3 id="DHCP">DHCP</h3>

<p>Il DHCP e il DNS sono gestiti dal processo di <code>dhcpcd</code>, lo standard DHCP client di Linux. Purtroppo esso non è in grado di reagire quanto la connessione di rete viene persa. Come conseguenza Firefox OS termina e riavvia <code>dhcpcd</code> ogni qualvolta si connette ad una data rete wireless.</p>

<p><code>dhcpcd</code> è anche responsabile per la configurazione della rotta di default; viene inoltre effettuata una chiamata al <em>network manager</em> per configurare i server DNS.</p>

<h2 id="Network_Manager">Network Manager</h2>

<p>Il gestore di rete (Network Manager) configura le interfacce di rete per le connettività 3G e WIFI.</p>

<div class="note notecard">
<p><strong>Nota:</strong> Questa sessione necessita di essere scritta.</p>
</div>

<h2 id="Processi_e_thread">Processi e thread</h2>

<p>Firefox OS utilizza i thread POSIX per implementare tutti i thread applicativi, inclusi i thread principali di ciascuna applicazione, i web workers e gli helper threads. I control group vengono utilizzati per gestire la priorità di esecuzione di processi e thread utilizzando lo scheduler standard di Linux. In funzione dello stato, il processo viene assegnato ad un differente control group. Abbiamo attualmente 6 livelli di priorità corrispondenti a 5 gruppi di controllo:</p>

<table style="height: 255px; width: 708px;" class="standard-table">
 <caption>Livello di priorità dei processi</caption>
 <thead>
  <tr>
   <th scope="col">Priorità</th>
   <th scope="col">Control group</th>
   <th scope="col">Utilizzato da</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>MASTER</code></td>
   <td> </td>
   <td>Processo b2g</td>
  </tr>
  <tr>
   <td><code>FOREGROUND_HIGH</code></td>
   <td>apps/critical</td>
   <td>Applicazioni che utilizzano CPU wakelock</td>
  </tr>
  <tr>
  </tr>
  <tr>
   <td><code>FOREGROUND</code></td>
   <td>apps</td>
   <td>Applicazioni in foreground (visibili all&apos;utente)</td>
  </tr>
  <tr>
   <td><code>FOREGROUND_KEYBOARD</code></td>
   <td>apps</td>
   <td>Applicazione tastiera</td>
  </tr>
  <tr>
   <td><code>BACKGROUND_PERCEIVABLE</code></td>
   <td>apps</td>
   <td>Applicazione audio in background (non visibili all&apos;utente)</td>
  </tr>
  <tr>
   <td><code>BACKGROUND</code></td>
   <td>apps/bg_non_interactive</td>
   <td>Tutte le altre applicazioni in esecuzione in background</td>
  </tr>
 </tbody>
</table>

<p>Alcuni livelli condividono lo stesso control group, in quanto quei livelli differiscono nella modalità con cui vengono gestiti dall&apos;<em>out of memory killer</em>. Tutte le proprietà possono essere configurate durante il processo di build attraverso le preferenze; le principali proprietà sono diponibili nel file <a href="http://hg.mozilla.org/mozilla-central/file/54e8c6492dc4/b2g/app/b2g.js#l610"><code>b2g/app/b2g.js</code></a>.</p>

<p>I seguenti control groups vengono attualmente utilizzati:</p>

<table class="standard-table">
 <caption>Control groups</caption>
 <thead>
  <tr>
   <th scope="col">Percorso</th>
   <th scope="col">Allocazione CPU</th>
   <th scope="col">Descrizione</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td> </td>
   <td>50% del tempo totale di CPU</td>
   <td>Control group di root riservato per il processo b2g principale per i deamon di sistema</td>
  </tr>
  <tr>
   <td><code>apps</code></td>
   <td>50% del tempo totale di CPU</td>
   <td>Applicazioni regolari</td>
  </tr>
  <tr>
   <td><code>apps/critical</code></td>
   <td>95% di <code>apps</code></td>
   <td>Applicazioni critiche</td>
  </tr>
  <tr>
   <td><code>apps/bg_perceivable</code></td>
   <td>10% di <code>apps</code></td>
   <td>Applicazioni di background percepibili</td>
  </tr>
  <tr>
   <td><code>apps/bg_non_interactive</code></td>
   <td>5% di <code>apps</code></td>
   <td>Applicazioni di background</td>
  </tr>
 </tbody>
</table>

<div class="note notecard">
<p><strong>Nota</strong>: Per maggiori informazioni sull&apos;out-of-memory killer e sulla modalità con cui Firefox OS gestisce le situazioni di memoria scarsa puoi leggere <a href="/en-US/Firefox_OS/Platform/Out_of_memory_management_on_Firefox_OS">Out of memory management on Firefox OS</a>.</p>
</div>

<p>All&apos;interno di un processo il thread principale eredita il valore di nice del processo, mentre ai thread dei web worker viene assegnato un valore di nice maggiore di un&apos;unità rispetto al thread principale, pertanto vengono eseguiti con una priorità inferiore. Questo per evitare che worker che fanno uso intensivo di CPU rallentino il thread principale. Le priorità sui processi vengono modificate in occasioni di eventi maggiori quali l&apos;invio in background o foreground dell&apos;applicazione, l&apos;avvio di una nuova applicazione o l&apos;acquisizione di CPU wakelock.</p>

<div class="note notecard">
<p><strong>Note:</strong> Attualmente non è possibile utilizzare cgroups su dispositivi ICS a causa di un bug nel kernel.</p>
</div>

<p> </p>

<p> </p>
