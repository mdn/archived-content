<p>When you add Persona support to your website, Persona takes on as much of the security burden as it can. However, some aspects of security can only be handled by your website. They're listed below.</p>
<h2 id="Essential_practices" name="Essential_practices">Essential practices</h2>
<h3 id="Verify_assertions_on_your_server" name="Verify_assertions_on_your_server">Verify assertions on your server</h3>
<p>When using Persona, identity assertions are passed into the <code>onlogin</code> function passed to {{ domxref("navigator.id.watch()") }}. You should <em>always</em> pass the assertion to your server for verification, and only your server should decide to grant the user additional permissions based on the verification result:</p>
<pre class="brush:js;">// Inside navigator.id.watch({ ...
onlogin: function(assertion) {
  // A user wants to log in! Here you need to:
  // 1. Send the assertion to your backend for verification and to create a session.
  // 2. Update your UI.
},
</pre>
<p>If you try to verify the assertion using the JavaScript executing in the user's browser, then a malicious user will be able to impersonate a legitimate user of your site by locally injecting code and subverting your JavaScript. This is possible because you're not fully in control of the user's browser, where the code executes.</p>
<p>Again, you should <em>always</em> pass the assertion to your server for verification. Even if you're using the remote verification API.</p>
<h3 id="Explicitly_specify_the_audience_parameter" name="Explicitly_specify_the_audience_parameter">Explicitly specify the audience parameter</h3>
<p>To verify an assertion, you may issue a POST request to<code> https://verifier.login.persona.org/verify</code>. The request includes a parameter called <code>audience</code>:</p>
<pre><code>assertion=&lt;ASSERTION&gt;&amp;audience=https://mysite.com:443"</code></pre>
<p>The <code>audience</code> parameter is required. You should always specify the audience explicitly in your code, or in your code's configuration. Specifically:</p>
<ul>
 <li>Do not trust the Host header sent by the user's browser.</li>
 <li>Do not trust an explicit parameter sent by the user's browser, but generated by your JavaScript using, e.g. <code>document.location</code>.</li>
</ul>
<p>If you trust the user's browser to tell you the audience, then it becomes possible for a malicious web site to reuse assertions for <em>its</em> web site to log into <em>your</em> web site.</p>
<h3 id="Verify_SSL_certificates" name="Verify_SSL_certificates">Verify SSL certificates</h3>
<p>To verify an assertion, you may issue a POST request to <code>https://verifier.login.persona.org/verify</code>. You must ensure that your HTTPS request verifies the certificate sent from the server against a trusted root certificate. If you don't, then an attacker could pose as <code>verifier.login.persona.org</code> and issue false verifications.</p>
<p>Check that the library you are using to make the request verifies certificates correctly, and that you are initializing it with the appropriate root certificate(s).</p>
<p>For example, Python 2.7's standard <a class="external" href="http://docs.python.org/release/2.7.3/library/urllib2.html#urllib2.urlopen" title="http://docs.python.org/release/2.7.3/library/urllib2.html#urllib2.urlopen">urllib2 module</a> does not validate server certificates. Instead, we recommend using the "<a class="external" href="http://pypi.python.org/pypi/requests">requests</a>" or "<a class="external" href="http://pypi.python.org/pypi/urllib3" title="http://pypi.python.org/pypi/urllib3">urllib3</a>" modules in Python 2.x, or the standard <code>http.client.HTTPSConnection</code> class in Python 3.x. For Perl, ensure that you are using at least version 6.0 of <code>libwww-perl</code>. Depending on the language, library, and operating system that you're using, you may need to supply either a list of trusted CA roots or the single CA used by <code>verifier.login.persona.org</code>.</p>
<h3 id="Implement_CSRF_protection" name="Implement_CSRF_protection">Implement CSRF protection</h3>
<p>In a CSRF (Cross-Site Request Forgery) login attack, an attacker uses a cross-site request forgery to log the user into a web site using the attacker's credentials.</p>
<p>For example: a user visits a malicious web site containing a <code>form</code> element. The form's <code>action</code> attribute is set to an HTTP POST request to <a class="external" href="http://www.google.com/login" title="http://www.google.com/login">http://www.google.com/login</a>, supplying the attacker's username and password. When the user submits the form, the request is sent to Google, the login succeeds and the Google server sets a cookie in the user's browser. Now the user's unknowingly logged into the attacker's Google account.</p>
<p>The attack can be used to gather sensitive information about the user. For example, Google's <a class="link-https" href="https://www.google.com/history/">Web History</a> feature logs all the user's Google search terms. If a user is logged into the attacker's Google account and the attacker has Web History enabled, then the user is giving the attacker all this information.</p>
<p>CSRF login attacks, and potential defenses against them, are documented more fully in <a class="external" href="http://www.adambarth.com/papers/2008/barth-jackson-mitchell-b.pdf">Robust Defenses for Cross-Site Request Forgery</a> (PDF). They're not specific to Persona: most login mechanisms are potentially vulnerable to them.</p>
<p>There are a variety of techniques which can be used to protect a site from CSRF login attacks, which are documented more fully in the study above.</p>
<p>One approach is to create a secret identifier in the server, shared with the browser, and require the browser to supply it when making login requests. For example:</p>
<ol>
 <li>As soon as the user lands on your site, before they try to log in, create a session for them on the server. Store the session ID in a browser cookie.</li>
 <li>On the server, generate a random string of at least 10 alphanumeric characters. A randomly generated UUID is a good option. This is the CSRF token. Store it in the session.</li>
 <li>Deliver the CSRF token to the browser by either embedding it in JavaScript or HTML as a hidden form variable.</li>
 <li>Ensure that the AJAX submission or form POST includes the CSRF token.</li>
 <li>On the server side, before accepting an assertion, check that the submitted CSRF token matches the session-stored CSRF token.</li>
</ol>
<h2 id="Enhancements" name="Enhancements">Enhancements</h2>
<h3 id="Content_Security_Policy_(CSP)" name="Content_Security_Policy_(CSP)">Content Security Policy (CSP)</h3>
<p><a href="/en-US/docs/Security/CSP" title="Security/CSP">Content Security Policy</a> (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware.</p>
<p>If you use CSP on your site, you may need to tweak your policy to enable Persona. Depending on your policy, you may need to:</p>
<ul>
 <li>Remove inline <code>javascript:</code> URIs and replace them with code loaded from an additional script file. The file can look up elements based on their ID, and then attach to the element by setting {{ domxref("element.onclick", "onclick") }} or calling {{ domxref("element.addEventListener()", "addEventListener()") }}.</li>
 <li>Allow <code>https://login.persona.org</code> as both a <code>script-src</code> and <code>frame-src</code> so that your site can load the remote <code>include.js</code> file and that file can communicate with the fallback Persona implementation.</li>
</ul>
<p>An example Apache configuration might include:</p>
<pre><span class="diff-content"><span class="idiff">Header set X-Content-Security-Policy: "default-src 'self'; frame-src 'self' https://login.persona.org ; script-src 'self' https://login.persona.org"</span></span></pre>